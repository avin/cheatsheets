# Структурные и слойные паттерны

## Layered Architecture (n-tier)

- **Суть**: разделение приложения на слои (презентация → приложение → домен → данные). Каждый слой взаимодействует только с соседними.
- **Когда применять**: классические монолиты, enterprise приложения, когда важна модульность и простота тестирования.
- **Плюсы**: понятная структура, тестируемость бизнес-логики, разделение ответственности.
- **Минусы**: может деградировать в "анемичный" домен, жёсткие ограничения на пересечение слойных границ.

## Hexagonal Architecture (Ports & Adapters)

- **Суть**: доменная логика изолирована, внешние интерфейсы подключаются через порты (интерфейсы) и адаптеры (реализации).
- **Когда**: нужна независимость от инфраструктуры (БД, UI), простота тестирования.
- **Плюсы**: лёгкая замена инфраструктуры, тестируемость, независимость от фреймворков.
- **Минусы**: повышается количество абстракций, непривычно для команд без опыта.

## Clean Architecture

- **Суть**: концентрические слои (Enterprise Business Rules → Application Business Rules → Interface Adapters → Frameworks & Drivers). Направление зависимостей внутрь.
- **Когда**: большие проекты с долгим жизненным циклом, строгие правила разделения.
- **Плюсы**: устойчивость к изменениям внешних условий, удобный unit-тестинг.
- **Минусы**: риск over-engineering, сложно в небольших командах.

## Modular Monolith

- **Суть**: монолитное приложение разделяется на независимые модули/"mini-сервисы" с жёсткими границами.
- **Когда**: нужно сохранить простоту деплоя монолита, но уменьшить связанность.
- **Плюсы**: единый деплой, но модульность, облегчённый переход в микросервисы.
- **Минусы**: всё ещё один процесс, требуют дисциплины границ модулей.

## Plugin Architecture / Microkernel

- **Суть**: ядро + плагины/модули, подключаемые динамически. Ядро отвечает за базовые функции, плагины расширяют ПО.
- **Когда**: IDE, CMS, приложения с кастомизацией (Photoshop, IntelliJ IDEA).
- **Плюсы**: легко расширять функциональность, сторонние разработчики могут делать плагины.
- **Минусы**: нужен стабильный API ядра, контроль безопасности плагинов.

## MVC / MVP / MVVM (UI/FM слои)

- **MVC**: Model-View-Controller; веб-фреймворки (Ruby on Rails, ASP.NET MVC).
- **MVP**: Model-View-Presenter, чаще в desktop/mobile.
- **MVVM**: Model-View-ViewModel (WPF, Android, SwiftUI) — data binding.
- **Когда**: тонкие клиенты, гибкое UI.
- **Плюсы**: разделение представления и логики.
- **Минусы**: риск смешивания обязанностей при нарушениях паттерна.

## Pipe and Filter

- **Суть**: данные проходят через цепочку фильтров (transforms).
- **Когда**: обработка потоков данных, ETL, компиляторы.
- **Плюсы**: переиспользуемые фильтры, параллельность.
- **Минусы**: затраты на сериализацию между шагами.

## Blackboard

- **Суть**: общая "доска", на которую компоненты выкладывают частичные решения; другие компоненты не знают друг о друге.
- **Когда**: задачи с множеством экспертов/алгоритмов (AI, распознавание образов).
- **Плюсы**: гибкость, добавление новых стратегий.
- **Минусы**: сложность координации, трудно тестировать.

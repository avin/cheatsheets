# Базовые концепции

Список напоминаний про оценку сложности и подготовительные математические факты.

## Анализ сложности

- Оценивайте верхнюю границу, считайте операции в худшем, среднем и амортизированном случаях.
- Для вложенных циклов проверяйте, не уменьшается ли размер задачи внутри итерации.
- При анализе рекурсий записывайте рекуррентность и решайте её (дерево рекурсии или Master theorem).

```cpp
int binary_search(const std::vector<int>& nums, int target) {
    int lo = 0;
    int hi = static_cast<int>(nums.size()) - 1;
    while (lo <= hi) { // O(log n)
        int mid = lo + (hi - lo) / 2;
        if (nums[mid] == target) {
            return mid;
        }
        if (nums[mid] < target) {
            lo = mid + 1;
        } else {
            hi = mid - 1;
        }
    }
    return -1;
}
```

## Амортизированный анализ

- Для структур с редкими дорогими операциями (динамический массив, heapify) суммируйте все операции и делите на количество вызовов.
- Банкировская методика: заведите «монетки», которые платят за дорогие операции.
- Потенциальная функция: оценивайте запас работы внутри структуры.

## Полезные формулы

- Сумма от 1 до n: `n * (n + 1) / 2`, сумма квадратов: `n * (n + 1) * (2n + 1) / 6`.
- Логарифмы: `log_a b = log_c b / log_c a`, часто удобно брать основание 2.
- Комбинаторика: `C(n, k) = n! / (k! (n-k)!)`, используйте динамику или предварительные факториалы.

```cpp
constexpr long long MOD = 1'000'000'007LL;

long long mod_pow(long long base, long long exp, long long mod = MOD) {
    long long result = 1 % mod;
    base %= mod;
    while (exp > 0) {
        if (exp & 1LL) {
            result = (result * base) % mod;
        }
        base = (base * base) % mod;
        exp >>= 1LL;
    }
    return result;
}
```

## НОД и НОК

- Используйте расширенный алгоритм Евклида для обратных элементов и линейных уравнений.
- `lcm(a, b) = a // gcd(a, b) * b`, следите за переполнением в C++.

```cpp
std::tuple<long long, long long, long long> extended_gcd(long long a, long long b) {
    if (b == 0) {
        return {a, 1, 0};
    }
    auto [g, x1, y1] = extended_gcd(b, a % b);
    long long x = y1;
    long long y = x1 - (a / b) * y1;
    return {g, x, y};
}
```

## Чек-лист перед решением

- Уточните формат входа/выхода, ограничения по времени и памяти.
- Спросите про сортировку, уникальность данных, к edge-case-ам (пустой массив, один элемент).
- Выберите структуру данных и опишите стратегию собеседующему перед кодом.

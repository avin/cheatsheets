/*
 * ============================================
 * ĞĞĞ¢Ğ˜ĞŸĞĞ¢Ğ¢Ğ•Ğ ĞĞ« C++ (Ğ§ĞµĞ³Ğ¾ ĞĞ• Ğ´ĞµĞ»Ğ°Ñ‚ÑŒ)
 * ============================================
 * 
 * Ğ Ğ°ÑĞ¿Ñ€Ğ¾ÑÑ‚Ñ€Ğ°Ğ½ĞµĞ½Ğ½Ñ‹Ğµ Ğ¾ÑˆĞ¸Ğ±ĞºĞ¸ Ğ¸ Ğ¿Ğ»Ğ¾Ñ…Ğ¸Ğµ Ğ¿Ñ€Ğ°ĞºÑ‚Ğ¸ĞºĞ¸ Ğ² C++
 * Ñ Ğ¾Ğ±ÑŠÑÑĞ½ĞµĞ½Ğ¸ÑĞ¼Ğ¸ Ğ¿Ğ¾Ñ‡ĞµĞ¼Ñƒ ÑÑ‚Ğ¾ Ğ¿Ğ»Ğ¾Ñ…Ğ¾ Ğ¸ ĞºĞ°Ğº Ğ´ĞµĞ»Ğ°Ñ‚ÑŒ Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ğ¾.
 * 
 * Ğ¢Ñ€ĞµĞ±Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ: C++20 Ğ¸Ğ»Ğ¸ Ğ²Ñ‹ÑˆĞµ
 * ĞšĞ¾Ğ¼Ğ¿Ğ¸Ğ»ÑÑ†Ğ¸Ñ: g++ -std=c++20 -Wall -Wextra anti_patterns.cpp
 */

#include <iostream>
#include <vector>
#include <memory>
#include <string>
#include <mutex>
#include <thread>
#include <optional>
#include <algorithm>
#include <fstream>

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“Œ MEMORY MANAGEMENT ANTI-PATTERNS (ĞĞĞ¢Ğ˜ĞŸĞĞ¢Ğ¢Ğ•Ğ ĞĞ« Ğ£ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ˜Ğ¯ ĞŸĞĞœĞ¯Ğ¢Ğ¬Ğ®)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// âŒ ĞŸĞ›ĞĞ¥Ğ: Ğ ÑƒÑ‡Ğ½Ğ¾Ğµ ÑƒĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ¿Ğ°Ğ¼ÑÑ‚ÑŒÑ Ñ new/delete
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class BadResourceManager {
private:
    int* data_;
    
public:
    BadResourceManager(int size) {
        data_ = new int[size];  // Ğ§Ñ‚Ğ¾ ĞµÑĞ»Ğ¸ Ğ²Ñ‹Ğ±Ñ€Ğ¾ÑĞ¸Ñ‚ÑŒÑÑ Ğ¸ÑĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğµ?
    }
    
    ~BadResourceManager() {
        delete[] data_;  // Ğ§Ñ‚Ğ¾ ĞµÑĞ»Ğ¸ Ğ·Ğ°Ğ±ÑƒĞ´ĞµĞ¼?
    }
    
    // ĞŸÑ€Ğ¾Ğ±Ğ»ĞµĞ¼Ñ‹:
    // 1. ĞĞµÑ‚ copy constructor/assignment - undefined behavior Ğ¿Ñ€Ğ¸ ĞºĞ¾Ğ¿Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğ¸
    // 2. Ğ£Ñ‚ĞµÑ‡ĞºĞ° Ğ¿Ğ°Ğ¼ÑÑ‚Ğ¸ Ğ¿Ñ€Ğ¸ Ğ¸ÑĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğ¸ Ğ² ĞºĞ¾Ğ½ÑÑ‚Ñ€ÑƒĞºÑ‚Ğ¾Ñ€Ğµ
    // 3. Double delete Ğ¿Ñ€Ğ¸ ĞºĞ¾Ğ¿Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğ¸ Ğ¿Ğ¾ ÑƒĞ¼Ğ¾Ğ»Ñ‡Ğ°Ğ½Ğ¸Ñ
    // 4. ĞÑƒĞ¶Ğ½Ğ¾ Ğ¿Ğ¾Ğ¼Ğ½Ğ¸Ñ‚ÑŒ Ğ¿Ñ€Ğ¾ Rule of Five - Ğ»ĞµĞ³ĞºĞ¾ Ğ·Ğ°Ğ±Ñ‹Ñ‚ÑŒ
};

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// âœ… Ğ¥ĞĞ ĞĞ¨Ğ: Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ RAII Ğ¸ ÑÑ‚Ğ°Ğ½Ğ´Ğ°Ñ€Ñ‚Ğ½Ñ‹Ğµ ĞºĞ¾Ğ½Ñ‚ĞµĞ¹Ğ½ĞµÑ€Ñ‹
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class GoodResourceManager {
private:
    std::vector<int> data_;  // ĞĞ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¾Ğµ ÑƒĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ¿Ğ°Ğ¼ÑÑ‚ÑŒÑ
    
public:
    GoodResourceManager(int size) : data_(size) {
        // Ğ’ÑĞµ Ğ±ĞµĞ·Ğ¾Ğ¿Ğ°ÑĞ½Ğ¾, Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸
    }
    
    // ĞšĞ¾Ğ¼Ğ¿Ğ¸Ğ»ÑÑ‚Ğ¾Ñ€ Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸ Ğ³ĞµĞ½ĞµÑ€Ğ¸Ñ€ÑƒĞµÑ‚:
    // - Copy constructor
    // - Move constructor  
    // - Copy assignment
    // - Move assignment
    // - Destructor
    // Ğ˜ Ğ²ÑĞµ Ğ¾Ğ½Ğ¸ ĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ñ‹!
};

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// âŒ ĞŸĞ›ĞĞ¥Ğ: Ğ¡Ğ¼ĞµÑˆĞ¸Ğ²Ğ°Ğ½Ğ¸Ğµ new[] Ğ¸ delete
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

int* arr = new int[10];
delete arr;  // âš ï¸ Ğ£Ğ‘! Ğ”Ğ¾Ğ»Ğ¶Ğ½Ğ¾ Ğ±Ñ‹Ñ‚ÑŒ delete[]

int* single = new int(42);
delete[] single;  // âš ï¸ Ğ£Ğ‘! Ğ”Ğ¾Ğ»Ğ¶Ğ½Ğ¾ Ğ±Ñ‹Ñ‚ÑŒ delete

// ĞŸÑ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ğ¾:
int* arr_good = new int[10];
delete[] arr_good;  // âœ…

int* single_good = new int(42);
delete single_good;  // âœ…

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// âŒ ĞŸĞ›ĞĞ¥Ğ: Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‚ raw pointer Ğ¸Ğ· new - Ğ½ĞµÑÑĞ½Ğ¾Ğµ ownership
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

int* bad_create_array(int size) {
    return new int[size];  // ĞšÑ‚Ğ¾ Ğ¾Ñ‚Ğ²ĞµÑ‡Ğ°ĞµÑ‚ Ğ·Ğ° ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ¸Ğµ? ĞĞµÑÑĞ½Ğ¾!
}

// Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ:
// int* arr = bad_create_array(100);
// ... Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ ...
// delete[] arr;  // Ğ ĞµÑĞ»Ğ¸ Ğ·Ğ°Ğ±ÑƒĞ´ĞµĞ¼? Ğ£Ñ‚ĞµÑ‡ĞºĞ°!

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// âœ… Ğ¥ĞĞ ĞĞ¨Ğ: Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°Ğ¹Ñ‚Ğµ ÑƒĞ¼Ğ½Ñ‹Ğµ ÑƒĞºĞ°Ğ·Ğ°Ñ‚ĞµĞ»Ğ¸ Ğ¸Ğ»Ğ¸ ĞºĞ¾Ğ½Ñ‚ĞµĞ¹Ğ½ĞµÑ€Ñ‹
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// Ğ’Ğ°Ñ€Ğ¸Ğ°Ğ½Ñ‚ 1: unique_ptr Ñ Ğ¼Ğ°ÑÑĞ¸Ğ²Ğ¾Ğ¼
std::unique_ptr<int[]> good_create_array(int size) {
    return std::make_unique<int[]>(size);
}

// Ğ’Ğ°Ñ€Ğ¸Ğ°Ğ½Ñ‚ 2: vector (ÑĞ°Ğ¼Ñ‹Ğ¹ Ğ»ÑƒÑ‡ÑˆĞ¸Ğ¹!)
std::vector<int> even_better_create_array(int size) {
    return std::vector<int>(size);
}

// Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ:
// auto arr = good_create_array(100);
// // ĞĞ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸ ÑƒĞ´Ğ°Ğ»Ğ¸Ñ‚ÑÑ Ğ¿Ñ€Ğ¸ Ğ²Ñ‹Ñ…Ğ¾Ğ´Ğµ Ğ¸Ğ· scope

// auto vec = even_better_create_array(100);
// // Ğ•Ñ‰Ñ‘ Ğ»ÑƒÑ‡ÑˆĞµ - Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ¼ĞµĞ½ÑÑ‚ÑŒ Ñ€Ğ°Ğ·Ğ¼ĞµÑ€, Ğ±ĞµĞ·Ğ¾Ğ¿Ğ°ÑĞ½Ğ¾ ĞºĞ¾Ğ¿Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// âŒ ĞŸĞ›ĞĞ¥Ğ: Ğ¥Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ğµ ÑÑ‹Ñ€Ñ‹Ñ… ÑƒĞºĞ°Ğ·Ğ°Ñ‚ĞµĞ»ĞµĞ¹ Ğ½Ğ° Ğ»Ğ¾ĞºĞ°Ğ»ÑŒĞ½Ñ‹Ğµ Ğ¿ĞµÑ€ĞµĞ¼ĞµĞ½Ğ½Ñ‹Ğµ
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

int x = 10, y = 20, z = 30;

// std::vector<int&> refs{x, y, z};  // âŒ ĞĞ• ĞšĞĞœĞŸĞ˜Ğ›Ğ˜Ğ Ğ£Ğ•Ğ¢Ğ¡Ğ¯!

// ĞĞ¾ ÑÑ‚Ğ¾ ĞºĞ¾Ğ¼Ğ¿Ğ¸Ğ»Ğ¸Ñ€ÑƒĞµÑ‚ÑÑ Ğ¸ Ğ¾Ğ¿Ğ°ÑĞ½Ğ¾:
std::vector<int*> ptrs{&x, &y, &z};
// âš ï¸ Ğ§Ñ‚Ğ¾ ĞµÑĞ»Ğ¸ x, y, z Ğ²Ñ‹Ñ…Ğ¾Ğ´ÑÑ‚ Ğ¸Ğ· scope? Dangling pointers!

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// âœ… Ğ¥ĞĞ ĞĞ¨Ğ: Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ std::reference_wrapper Ğ´Ğ»Ñ Ğ±ĞµĞ·Ğ¾Ğ¿Ğ°ÑĞ½Ğ¾ÑÑ‚Ğ¸
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

int a = 10, b = 20, c = 30;
std::vector<std::reference_wrapper<int>> refs{a, b, c};

// Ğ˜Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ğµ Ñ‡ĞµÑ€ĞµĞ· reference_wrapper
for (auto& ref : refs) {
    ref.get() += 10;
}
// a = 20, b = 30, c = 40

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// âŒ ĞŸĞ›ĞĞ¥Ğ: Ğ—Ğ°Ğ±Ñ‹Ñ‚Ñ‹Ğ¹ delete Ğ² Ğ¸ÑĞºĞ»ÑÑ‡Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ñ… ÑĞ¸Ñ‚ÑƒĞ°Ñ†Ğ¸ÑÑ…
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

int* data = new int[100];

// Ğ•ÑĞ»Ğ¸ Ğ·Ğ´ĞµÑÑŒ Ğ±Ñ€Ğ¾ÑĞ¸Ñ‚ÑÑ Ğ¸ÑĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğµ, data ÑƒÑ‚ĞµÑ‡Ñ‘Ñ‚
// process_data(data);  

delete[] data;  // âš ï¸ ĞœĞ¾Ğ¶ĞµÑ‚ Ğ½Ğµ Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ÑŒÑÑ Ğ¿Ñ€Ğ¸ Ğ¸ÑĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğ¸!

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// âœ… Ğ¥ĞĞ ĞĞ¨Ğ: RAII Ğ³Ğ°Ñ€Ğ°Ğ½Ñ‚Ğ¸Ñ€ÑƒĞµÑ‚ Ğ¾Ñ‡Ğ¸ÑÑ‚ĞºÑƒ Ğ´Ğ°Ğ¶Ğµ Ğ¿Ñ€Ğ¸ Ğ¸ÑĞºĞ»ÑÑ‡ĞµĞ½Ğ¸ÑÑ…
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

auto data_safe = std::make_unique<int[]>(100);

// Ğ”Ğ°Ğ¶Ğµ ĞµÑĞ»Ğ¸ Ğ·Ğ´ĞµÑÑŒ Ğ¸ÑĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğµ, unique_ptr Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸ Ğ¾Ñ‡Ğ¸ÑÑ‚Ğ¸Ñ‚ Ğ¿Ğ°Ğ¼ÑÑ‚ÑŒ
// process_data(data_safe.get());

// delete Ğ½Ğµ Ğ½ÑƒĞ¶ĞµĞ½ - Ğ´ĞµÑÑ‚Ñ€ÑƒĞºÑ‚Ğ¾Ñ€ unique_ptr Ğ²ÑÑ‘ ÑĞ´ĞµĞ»Ğ°ĞµÑ‚



// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“Œ EXCEPTION SAFETY ANTI-PATTERNS (ĞĞĞ¢Ğ˜ĞŸĞĞ¢Ğ¢Ğ•Ğ ĞĞ« Ğ‘Ğ•Ğ—ĞĞŸĞĞ¡ĞĞĞ¡Ğ¢Ğ˜ Ğ˜Ğ¡ĞšĞ›Ğ®Ğ§Ğ•ĞĞ˜Ğ™)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// âŒ ĞŸĞ›ĞĞ¥Ğ: Ğ‘Ñ€Ğ¾ÑĞ°Ğ½Ğ¸Ğµ Ğ¸ÑĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğ¹ Ğ² Ğ´ĞµÑÑ‚Ñ€ÑƒĞºÑ‚Ğ¾Ñ€Ğµ
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class BadDestructor {
    ~BadDestructor() {
        // Ğ•ÑĞ»Ğ¸ Ğ´ĞµÑÑ‚Ñ€ÑƒĞºÑ‚Ğ¾Ñ€ Ğ²Ñ‹Ğ·Ğ²Ğ°Ğ½ Ğ²Ğ¾ Ğ²Ñ€ĞµĞ¼Ñ Ñ€Ğ°ÑĞºÑ€ÑƒÑ‚ĞºĞ¸ ÑÑ‚ĞµĞºĞ° Ğ¸Ğ·-Ğ·Ğ° Ğ¸ÑĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ñ,
        // Ğ¸ Ğ·Ğ´ĞµÑÑŒ Ğ±Ñ€Ğ¾ÑĞ¸Ñ‚ÑÑ ĞµÑ‰Ñ‘ Ğ¾Ğ´Ğ½Ğ¾ - std::terminate()!
        throw std::runtime_error("Oops");  // âš ï¸ ĞĞ˜ĞšĞĞ“Ğ”Ğ Ğ¢ĞĞš ĞĞ• Ğ”Ğ•Ğ›ĞĞ™Ğ¢Ğ•!
    }
};

/*
 * ĞŸÑ€Ğ¾Ğ±Ğ»ĞµĞ¼Ğ°: ĞµÑĞ»Ğ¸ ÑƒĞ¶Ğµ Ğ¸Ğ´Ñ‘Ñ‚ Ñ€Ğ°ÑĞºÑ€ÑƒÑ‚ĞºĞ° ÑÑ‚ĞµĞºĞ° Ğ¸Ğ·-Ğ·Ğ° Ğ¸ÑĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ñ,
 * Ğ¸ Ğ´ĞµÑÑ‚Ñ€ÑƒĞºÑ‚Ğ¾Ñ€ Ğ±Ñ€Ğ¾ÑĞ¸Ñ‚ Ğ²Ñ‚Ğ¾Ñ€Ğ¾Ğµ Ğ¸ÑĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğµ - Ğ¿Ñ€Ğ¾Ğ³Ñ€Ğ°Ğ¼Ğ¼Ğ° Ğ°Ğ²Ğ°Ñ€Ğ¸Ğ¹Ğ½Ğ¾ Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞ¸Ñ‚ÑÑ.
 * C++ Ğ½Ğµ Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°Ñ‚ÑŒ Ğ´Ğ²Ğ° Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ñ… Ğ¸ÑĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ñ Ğ¾Ğ´Ğ½Ğ¾Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ½Ğ¾.
 */

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// âœ… Ğ¥ĞĞ ĞĞ¨Ğ: Ğ”ĞµÑÑ‚Ñ€ÑƒĞºÑ‚Ğ¾Ñ€Ñ‹ Ğ´Ğ¾Ğ»Ğ¶Ğ½Ñ‹ Ğ±Ñ‹Ñ‚ÑŒ noexcept
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class GoodDestructor {
    ~GoodDestructor() noexcept {
        try {
            // ĞĞ¿Ğ°ÑĞ½Ğ°Ñ Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸Ñ Ğ¾Ñ‡Ğ¸ÑÑ‚ĞºĞ¸
            // cleanup();
        } catch (...) {
            // Ğ›Ğ¾Ğ³Ğ¸Ñ€ÑƒĞµĞ¼ Ğ¾ÑˆĞ¸Ğ±ĞºÑƒ, Ğ½Ğ¾ ĞĞ• Ğ±Ñ€Ğ¾ÑĞ°ĞµĞ¼ Ğ´Ğ°Ğ»ÑŒÑˆĞµ
            // std::cerr << "Cleanup failed\n";
        }
    }
};

// Ğ’ÑĞµ Ğ´ĞµÑÑ‚Ñ€ÑƒĞºÑ‚Ğ¾Ñ€Ñ‹ Ğ¿Ğ¾ ÑƒĞ¼Ğ¾Ğ»Ñ‡Ğ°Ğ½Ğ¸Ñ noexcept(true) Ğ² C++11+
// Ğ¯Ğ²Ğ½Ğ¾ Ğ¿Ğ¾Ğ¼ĞµÑ‡Ğ°Ğ¹Ñ‚Ğµ noexcept Ğ´Ğ»Ñ ÑÑĞ½Ğ¾ÑÑ‚Ğ¸

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// âŒ ĞŸĞ›ĞĞ¥Ğ: catch(...) Ğ±ĞµĞ· rethrow Ğ¿Ñ€Ğ¾Ğ³Ğ»Ğ°Ñ‚Ñ‹Ğ²Ğ°ĞµÑ‚ Ğ¾ÑˆĞ¸Ğ±ĞºĞ¸
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// try {
//     dangerous_operation();
// } catch (...) {
//     // ĞŸÑ€Ğ¾ÑÑ‚Ğ¾ Ğ»Ğ¾Ğ³Ğ¸Ñ€ÑƒĞµĞ¼
//     // std::cout << "Something went wrong\n";
//     // âš ï¸ Ğ˜ÑĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğµ Ğ¿Ñ€Ğ¾Ğ³Ğ»Ğ¾Ñ‡ĞµĞ½Ğ¾ - Ğ²Ñ‹Ğ·Ñ‹Ğ²Ğ°ÑÑ‰Ğ¸Ğ¹ ĞºĞ¾Ğ´ Ğ½Ğµ ÑƒĞ·Ğ½Ğ°ĞµÑ‚ Ğ¾Ğ± Ğ¾ÑˆĞ¸Ğ±ĞºĞµ!
// }

// Ğ’Ñ‹Ğ·Ñ‹Ğ²Ğ°ÑÑ‰Ğ¸Ğ¹ ĞºĞ¾Ğ´ Ğ´ÑƒĞ¼Ğ°ĞµÑ‚, Ñ‡Ñ‚Ğ¾ Ğ²ÑÑ‘ Ñ…Ğ¾Ñ€Ğ¾ÑˆĞ¾, Ğ¿Ñ€Ğ¾Ğ´Ğ¾Ğ»Ğ¶Ğ°ĞµÑ‚ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñƒ Ñ Ğ½ĞµĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ñ‹Ğ¼ ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸ĞµĞ¼

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// âœ… Ğ¥ĞĞ ĞĞ¨Ğ: ĞĞ±Ñ€Ğ°Ğ±Ğ°Ñ‚Ñ‹Ğ²Ğ°Ğ¹Ñ‚Ğµ Ñ‡Ñ‚Ğ¾ Ğ¼Ğ¾Ğ¶ĞµÑ‚Ğµ, Ğ¾ÑÑ‚Ğ°Ğ»ÑŒĞ½Ğ¾Ğµ Ğ¿Ñ€Ğ¾Ğ±Ñ€Ğ°ÑÑ‹Ğ²Ğ°Ğ¹Ñ‚Ğµ
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// try {
//     dangerous_operation();
// } catch (const std::runtime_error& e) {
//     // ĞĞ±Ñ€Ğ°Ğ±Ğ°Ñ‚Ñ‹Ğ²Ğ°ĞµĞ¼ Ñ‚Ğ¾, Ñ‡Ñ‚Ğ¾ Ğ·Ğ½Ğ°ĞµĞ¼ ĞºĞ°Ğº Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°Ñ‚ÑŒ
//     // std::cerr << "Runtime error: " << e.what() << '\n';
//     // ĞœĞ¾Ğ¶ĞµĞ¼ Ğ²Ğ¾ÑÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒÑÑ - Ğ¿Ñ€Ğ¾Ğ´Ğ¾Ğ»Ğ¶Ğ°ĞµĞ¼
// } catch (const std::logic_error& e) {
//     // Ğ›Ğ¾Ğ³Ğ¸Ñ‡ĞµÑĞºĞ°Ñ Ğ¾ÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¾Ğ³Ñ€Ğ°Ğ¼Ğ¼Ğ¸ÑÑ‚Ğ° - Ğ»Ğ¾Ğ³Ğ¸Ñ€ÑƒĞµĞ¼ Ğ¸ Ğ¿Ñ€Ğ¾Ğ±Ñ€Ğ°ÑÑ‹Ğ²Ğ°ĞµĞ¼
//     // std::cerr << "Logic error: " << e.what() << '\n';
//     throw;
// } catch (...) {
//     // ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ğ°Ñ Ğ¾ÑˆĞ¸Ğ±ĞºĞ° - Ğ»Ğ¾Ğ³Ğ¸Ñ€ÑƒĞµĞ¼ Ğ¸ Ğ¿Ñ€Ğ¾Ğ±Ñ€Ğ°ÑÑ‹Ğ²Ğ°ĞµĞ¼
//     // std::cerr << "Unknown error\n";
//     throw;  // âœ… ĞŸÑ€Ğ¾Ğ±Ñ€Ğ°ÑÑ‹Ğ²Ğ°ĞµĞ¼ Ğ´Ğ°Ğ»ÑŒÑˆĞµ!
// }

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// âŒ ĞŸĞ›ĞĞ¥Ğ: Ğ˜Ğ³Ğ½Ğ¾Ñ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ exception safety guarantees
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class BadVector {
    int* data_;
    size_t size_;
    
    void push_back(int value) {
        // ĞŸÑ€Ğ¾Ğ±Ğ»ĞµĞ¼Ğ°: ĞµÑĞ»Ğ¸ new Ğ±Ñ€Ğ¾ÑĞ¸Ñ‚ Ğ¸ÑĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾ÑĞ»Ğµ delete,
        // Ğ¼Ñ‹ Ğ¿Ğ¾Ñ‚ĞµÑ€ÑĞµĞ¼ ÑÑ‚Ğ°Ñ€Ñ‹Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ!
        int* new_data = new int[size_ + 1];  // ĞœĞ¾Ğ¶ĞµÑ‚ Ğ±Ñ€Ğ¾ÑĞ¸Ñ‚ÑŒ
        delete[] data_;  // âš ï¸ Ğ¡Ñ‚Ğ°Ñ€Ñ‹Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ¿Ğ¾Ñ‚ĞµÑ€ÑĞ½Ñ‹!
        data_ = new_data;  // Ğ•ÑĞ»Ğ¸ Ğ·Ğ´ĞµÑÑŒ Ğ¸ÑĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğµ - ÑƒÑ‚ĞµÑ‡ĞºĞ°
        data_[size_] = value;
        ++size_;
    }
};

/*
 * Ğ£Ñ€Ğ¾Ğ²Ğ½Ğ¸ exception safety:
 * 1. No-throw guarantee: Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸Ñ Ğ½Ğµ Ğ±Ñ€Ğ¾ÑĞ°ĞµÑ‚ Ğ¸ÑĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğ¹ (noexcept)
 * 2. Strong guarantee: Ğ»Ğ¸Ğ±Ğ¾ ÑƒÑĞ¿ĞµÑ…, Ğ»Ğ¸Ğ±Ğ¾ ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ Ğ½Ğµ Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¾
 * 3. Basic guarantee: Ğ½ĞµÑ‚ ÑƒÑ‚ĞµÑ‡ĞµĞº, Ğ¸Ğ½Ğ²Ğ°Ñ€Ğ¸Ğ°Ğ½Ñ‚Ñ‹ ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ñ‹, Ğ½Ğ¾ ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ğ¸Ğ·Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒÑÑ
 * 4. No guarantee: Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ğ±Ñ‹Ñ‚ÑŒ Ñ‡Ñ‚Ğ¾ ÑƒĞ³Ğ¾Ğ´Ğ½Ğ¾ (Ğ¿Ğ»Ğ¾Ñ…Ğ¾!)
 */

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// âœ… Ğ¥ĞĞ ĞĞ¨Ğ: Strong exception guarantee
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class GoodVector {
    std::vector<int> data_;
    
    void push_back(int value) {
        // std::vector Ğ³Ğ°Ñ€Ğ°Ğ½Ñ‚Ğ¸Ñ€ÑƒĞµÑ‚ strong exception safety:
        // Ğ»Ğ¸Ğ±Ğ¾ Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸Ñ ÑƒÑĞ¿ĞµÑˆĞ½Ğ°, Ğ»Ğ¸Ğ±Ğ¾ ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ Ğ½Ğµ Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¾
        data_.push_back(value);
    }
};

// Ğ ĞµĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ñ strong guarantee Ğ²Ñ€ÑƒÑ‡Ğ½ÑƒÑ:
class ManualStrongGuarantee {
    int* data_;
    size_t size_;
    
    void push_back(int value) {
        // Ğ¡Ğ½Ğ°Ñ‡Ğ°Ğ»Ğ° Ğ²Ñ‹Ğ´ĞµĞ»ÑĞµĞ¼ Ğ½Ğ¾Ğ²ÑƒÑ Ğ¿Ğ°Ğ¼ÑÑ‚ÑŒ
        int* new_data = new int[size_ + 1];  // ĞœĞ¾Ğ¶ĞµÑ‚ Ğ±Ñ€Ğ¾ÑĞ¸Ñ‚ÑŒ
        
        // ĞšĞ¾Ğ¿Ğ¸Ñ€ÑƒĞµĞ¼ ÑÑ‚Ğ°Ñ€Ñ‹Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ (Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ğ±Ñ€Ğ¾ÑĞ¸Ñ‚ÑŒ ĞµÑĞ»Ğ¸ int Ğ¸Ğ¼ĞµĞµÑ‚ Ğ½ĞµÑ‚Ñ€Ğ¸Ğ²Ğ¸Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹ ĞºĞ¾Ğ½ÑÑ‚Ñ€ÑƒĞºÑ‚Ğ¾Ñ€)
        std::copy(data_, data_ + size_, new_data);
        
        // Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ½Ğ¾Ğ²Ñ‹Ğ¹ ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚
        new_data[size_] = value;
        
        // Ğ¢Ğ¾Ğ»ÑŒĞºĞ¾ Ñ‚ĞµĞ¿ĞµÑ€ÑŒ Ğ¼ĞµĞ½ÑĞµĞ¼ ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ (Ğ²ÑĞµ Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸Ğ¸ Ğ²Ñ‹ÑˆĞµ Ğ¼Ğ¾Ğ³Ğ»Ğ¸ Ğ±Ñ€Ğ¾ÑĞ¸Ñ‚ÑŒ, Ğ½Ğ¾ data_ Ğ½Ğµ Ñ‚Ñ€Ğ¾Ğ½ÑƒÑ‚)
        delete[] data_;
        data_ = new_data;
        ++size_;
    }
};

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// âŒ ĞŸĞ›ĞĞ¥Ğ: Ğ˜ÑĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ñ Ğ² noexcept Ñ„ÑƒĞ½ĞºÑ†Ğ¸ÑÑ…
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

void bad_noexcept() noexcept {
    throw std::runtime_error("Oops");  // âš ï¸ std::terminate() Ğ±ÑƒĞ´ĞµÑ‚ Ğ²Ñ‹Ğ·Ğ²Ğ°Ğ½!
}

// Ğ•ÑĞ»Ğ¸ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ¿Ğ¾Ğ¼ĞµÑ‡ĞµĞ½Ğ° noexcept, Ğ½Ğ¾ Ğ²ÑÑ‘ Ğ¶Ğµ Ğ±Ñ€Ğ¾ÑĞ°ĞµÑ‚ - Ğ½ĞµĞ¼ĞµĞ´Ğ»ĞµĞ½Ğ½Ñ‹Ğ¹ std::terminate()
// ĞĞµÑ‚ Ğ²Ğ¾Ğ·Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ÑÑ‚Ğ¸ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°Ñ‚ÑŒ Ğ¸ÑĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğµ

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// âœ… Ğ¥ĞĞ ĞĞ¨Ğ: ĞĞµ Ğ¿Ğ¾Ğ¼ĞµÑ‡Ğ°Ğ¹Ñ‚Ğµ noexcept, ĞµÑĞ»Ğ¸ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ğ±Ñ€Ğ¾ÑĞ¸Ñ‚ÑŒ
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

void good_function() {
    // ĞœĞ¾Ğ¶ĞµÑ‚ Ğ±Ñ€Ğ¾ÑĞ¸Ñ‚ÑŒ Ğ¸ÑĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğµ - ÑÑ‚Ğ¾ Ğ½Ğ¾Ñ€Ğ¼Ğ°Ğ»ÑŒĞ½Ğ¾
    throw std::runtime_error("This is fine");
}

// Ğ˜Ğ»Ğ¸ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ°Ñ‚Ñ‹Ğ²Ğ°Ğ¹Ñ‚Ğµ Ğ²ÑĞµ Ğ²Ğ½ÑƒÑ‚Ñ€Ğ¸, ĞµÑĞ»Ğ¸ Ğ½ÑƒĞ¶ĞµĞ½ noexcept:
void good_noexcept() noexcept {
    try {
        // dangerous_operation();
    } catch (...) {
        // ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°Ğ½Ğ¾ Ğ²Ğ½ÑƒÑ‚Ñ€Ğ¸, Ğ½Ğ°Ñ€ÑƒĞ¶Ñƒ Ğ½Ğµ Ğ²Ñ‹Ñ…Ğ¾Ğ´Ğ¸Ñ‚
    }
}

// ĞšĞ¾Ğ³Ğ´Ğ° Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ noexcept:
// - Ğ”ĞµÑÑ‚Ñ€ÑƒĞºÑ‚Ğ¾Ñ€Ñ‹ (Ğ¾Ğ±ÑĞ·Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ğ¾!)
// - Move ĞºĞ¾Ğ½ÑÑ‚Ñ€ÑƒĞºÑ‚Ğ¾Ñ€Ñ‹ Ğ¸ move assignment (Ğ´Ğ»Ñ Ğ¿Ñ€Ğ¾Ğ¸Ğ·Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ¾ÑÑ‚Ğ¸ ĞºĞ¾Ğ½Ñ‚ĞµĞ¹Ğ½ĞµÑ€Ğ¾Ğ²)
// - Swap Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ğ¸
// - Ğ¤ÑƒĞ½ĞºÑ†Ğ¸Ğ¸, ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğµ Ğ³Ğ°Ñ€Ğ°Ğ½Ñ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ğ¾ Ğ½Ğµ Ğ±Ñ€Ğ¾ÑĞ°ÑÑ‚ (Ğ½Ğ°Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€, getters)




// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“Œ CONCURRENCY ANTI-PATTERNS (ĞĞĞ¢Ğ˜ĞŸĞĞ¢Ğ¢Ğ•Ğ ĞĞ« ĞœĞĞĞ“ĞĞŸĞĞ¢ĞĞ§ĞĞĞ¡Ğ¢Ğ˜)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// âŒ ĞŸĞ›ĞĞ¥Ğ: Data race - Ğ³Ğ¾Ğ½ĞºĞ° Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class BadCounter {
    int count_ = 0;
    
public:
    void increment() {
        ++count_;  // âš ï¸ ĞĞ• ĞĞ¢ĞĞœĞĞ ĞĞ! Race condition!
    }
    
    int get() const {
        return count_;  // Ğ¢Ğ¾Ğ¶Ğµ Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ğ²ĞµÑ€Ğ½ÑƒÑ‚ÑŒ "Ñ€Ğ°Ğ·Ğ¾Ñ€Ğ²Ğ°Ğ½Ğ½Ğ¾Ğµ" Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ
    }
};

/*
 * ĞŸÑ€Ğ¾Ğ±Ğ»ĞµĞ¼Ğ°: ++ ÑÑ‚Ğ¾ Ñ‚Ñ€Ğ¸ Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸Ğ¸ (read, increment, write)
 * Ğ”Ğ²Ğ° Ğ¿Ğ¾Ñ‚Ğ¾ĞºĞ° Ğ¼Ğ¾Ğ³ÑƒÑ‚ Ğ¿Ñ€Ğ¾Ñ‡Ğ¸Ñ‚Ğ°Ñ‚ÑŒ Ğ¾Ğ´Ğ½Ğ¾ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ, Ğ¸Ğ½ĞºÑ€ĞµĞ¼ĞµĞ½Ñ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ, Ğ·Ğ°Ğ¿Ğ¸ÑĞ°Ñ‚ÑŒ
 * Ğ ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚: Ğ¿Ğ¾Ñ‚ĞµÑ€ÑĞ½Ğ° Ğ¾Ğ´Ğ½Ğ° Ğ¸Ğ½ĞºÑ€ĞµĞ¼ĞµĞ½Ñ‚Ğ°Ñ†Ğ¸Ñ
 */

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// âœ… Ğ¥ĞĞ ĞĞ¨Ğ: Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ Ğ°Ñ‚Ğ¾Ğ¼Ğ°Ñ€Ğ½Ñ‹Ğµ Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸Ğ¸
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class GoodCounter {
    std::atomic<int> count_{0};
    
public:
    void increment() {
        ++count_;  // âœ… ĞÑ‚Ğ¾Ğ¼Ğ°Ñ€Ğ½Ğ°Ñ Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸Ñ
    }
    
    int get() const {
        return count_.load();
    }
    
    // Ğ¢Ğ°ĞºĞ¶Ğµ ĞµÑÑ‚ÑŒ Ğ´Ñ€ÑƒĞ³Ğ¸Ğµ Ğ¿Ğ¾Ğ»ĞµĞ·Ğ½Ñ‹Ğµ Ğ°Ñ‚Ğ¾Ğ¼Ğ°Ñ€Ğ½Ñ‹Ğµ Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸Ğ¸:
    int fetch_add(int value) {
        return count_.fetch_add(value);  // Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµÑ‚ ÑÑ‚Ğ°Ñ€Ğ¾Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ
    }
    
    void add(int value) {
        count_ += value;  // ĞÑ‚Ğ¾Ğ¼Ğ°Ñ€Ğ½Ğ¾
    }
};

// Ğ˜Ğ»Ğ¸ Ñ Ğ¼ÑŒÑÑ‚ĞµĞºÑĞ¾Ğ¼ (ĞºĞ¾Ğ³Ğ´Ğ° Ğ½ÑƒĞ¶Ğ½Ğ¾ Ğ·Ğ°Ñ‰Ğ¸Ñ‚Ğ¸Ñ‚ÑŒ Ğ½ĞµÑĞºĞ¾Ğ»ÑŒĞºĞ¾ Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸Ğ¹):
class GoodCounterWithMutex {
    mutable std::mutex mutex_;
    int count_ = 0;
    
public:
    void increment() {
        std::lock_guard lock(mutex_);
        ++count_;
    }
    
    int get() const {
        std::lock_guard lock(mutex_);
        return count_;
    }
};

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// âŒ ĞŸĞ›ĞĞ¥Ğ: Deadlock Ğ¸Ğ·-Ğ·Ğ° Ğ½ĞµĞ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ğ¾Ğ³Ğ¾ Ğ¿Ğ¾Ñ€ÑĞ´ĞºĞ° Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²ĞºĞ¸
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class BadBankAccount {
    mutable std::mutex mutex_;
    double balance_;
    
public:
    void transfer(BadBankAccount& to, double amount) {
        std::lock_guard lock1(mutex_);        // Ğ‘Ğ»Ğ¾ĞºĞ¸Ñ€ÑƒĞµĞ¼ this
        std::lock_guard lock2(to.mutex_);     // Ğ‘Ğ»Ğ¾ĞºĞ¸Ñ€ÑƒĞµĞ¼ to
        
        // âš ï¸ DEADLOCK ĞµÑĞ»Ğ¸ Ğ´Ğ²Ğ° Ğ¿Ğ¾Ñ‚Ğ¾ĞºĞ° Ğ²Ñ‹Ğ·Ñ‹Ğ²Ğ°ÑÑ‚:
        // ĞŸĞ¾Ñ‚Ğ¾Ğº 1: A.transfer(B, 100) - Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€ÑƒĞµÑ‚ A, Ğ¿Ğ¾Ñ‚Ğ¾Ğ¼ Ğ¿Ñ‹Ñ‚Ğ°ĞµÑ‚ÑÑ B
        // ĞŸĞ¾Ñ‚Ğ¾Ğº 2: B.transfer(A, 50)  - Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€ÑƒĞµÑ‚ B, Ğ¿Ğ¾Ñ‚Ğ¾Ğ¼ Ğ¿Ñ‹Ñ‚Ğ°ĞµÑ‚ÑÑ A
        // Ğ’Ğ·Ğ°Ğ¸Ğ¼Ğ½Ğ°Ñ Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²ĞºĞ°!
        
        balance_ -= amount;
        to.balance_ += amount;
    }
};

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// âœ… Ğ¥ĞĞ ĞĞ¨Ğ: Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ std::scoped_lock Ğ´Ğ»Ñ Ğ¼Ğ½Ğ¾Ğ¶ĞµÑÑ‚Ğ²ĞµĞ½Ğ½Ñ‹Ñ… Ğ¼ÑŒÑÑ‚ĞµĞºÑĞ¾Ğ²
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class GoodBankAccount {
    mutable std::mutex mutex_;
    double balance_;
    
public:
    void transfer(GoodBankAccount& to, double amount) {
        // std::scoped_lock (C++17) Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€ÑƒĞµÑ‚ Ğ¾Ğ±Ğ° Ğ¼ÑŒÑÑ‚ĞµĞºÑĞ° Ğ°Ñ‚Ğ¾Ğ¼Ğ°Ñ€Ğ½Ğ¾
        // Ğ² Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ğ¾Ğ¼ Ğ¿Ğ¾Ñ€ÑĞ´ĞºĞµ (Ğ¿Ğ¾ Ğ°Ğ´Ñ€ĞµÑÑƒ), Ğ¸Ğ·Ğ±ĞµĞ³Ğ°Ñ deadlock
        std::scoped_lock lock(mutex_, to.mutex_);
        
        balance_ -= amount;
        to.balance_ += amount;
    }
    
    // ĞĞ»ÑŒÑ‚ĞµÑ€Ğ½Ğ°Ñ‚Ğ¸Ğ²Ğ° Ğ´Ğ»Ñ C++11/14:
    void transfer_cpp11(GoodBankAccount& to, double amount) {
        std::lock(mutex_, to.mutex_);  // Ğ‘Ğ»Ğ¾ĞºĞ¸Ñ€ÑƒĞµÑ‚ Ğ¾Ğ±Ğ° Ğ°Ñ‚Ğ¾Ğ¼Ğ°Ñ€Ğ½Ğ¾
        std::lock_guard lock1(mutex_, std::adopt_lock);
        std::lock_guard lock2(to.mutex_, std::adopt_lock);
        
        balance_ -= amount;
        to.balance_ += amount;
    }
};

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// âŒ ĞŸĞ›ĞĞ¥Ğ: Ğ—Ğ°Ğ±Ñ‹Ñ‚Ñ‹Ğ¹ unlock - ÑƒÑ‚ĞµÑ‡ĞºĞ° Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²ĞºĞ¸
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

std::mutex m;
int shared_data = 0;

// m.lock();
// 
// if (shared_data < 0) {
//     return;  // âš ï¸ Ğ£Ğ¢Ğ•Ğ§ĞšĞ Ğ‘Ğ›ĞĞšĞ˜Ğ ĞĞ’ĞšĞ˜! Ğ—Ğ°Ğ±Ñ‹Ğ»Ğ¸ unlock!
// }
// 
// ++shared_data;
// m.unlock();

// ĞœÑŒÑÑ‚ĞµĞºÑ Ğ¾ÑÑ‚Ğ°Ğ½ĞµÑ‚ÑÑ Ğ·Ğ°Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğ¼ Ğ½Ğ°Ğ²ÑĞµĞ³Ğ´Ğ° - deadlock Ğ´Ğ»Ñ Ğ´Ñ€ÑƒĞ³Ğ¸Ñ… Ğ¿Ğ¾Ñ‚Ğ¾ĞºĞ¾Ğ²

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// âœ… Ğ¥ĞĞ ĞĞ¨Ğ: Ğ’ÑĞµĞ³Ğ´Ğ° Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ RAII Ğ´Ğ»Ñ Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²Ğ¾Ğº
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// std::lock_guard lock(m);
// 
// if (shared_data < 0) {
//     return;  // âœ… OK, lock Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸ Ñ€Ğ°Ğ·Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€ÑƒĞµÑ‚ÑÑ
// }
// 
// ++shared_data;
// // ĞĞ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸Ğ¹ unlock Ğ¿Ñ€Ğ¸ Ğ²Ñ‹Ñ…Ğ¾Ğ´Ğµ Ğ¸Ğ· scope

// Ğ’Ğ°Ñ€Ğ¸Ğ°Ğ½Ñ‚Ñ‹ RAII-Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²Ğ¾Ğº:
// - std::lock_guard - Ğ¿Ñ€Ğ¾ÑÑ‚Ğ°Ñ Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²ĞºĞ°
// - std::unique_lock - Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ñ€Ğ°Ğ·Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ²Ñ€ÑƒÑ‡Ğ½ÑƒÑ, Ğ¿ĞµÑ€ĞµĞ´Ğ²Ğ¸Ğ³Ğ°Ñ‚ÑŒ
// - std::scoped_lock (C++17) - Ğ´Ğ»Ñ Ğ½ĞµÑĞºĞ¾Ğ»ÑŒĞºĞ¸Ñ… Ğ¼ÑŒÑÑ‚ĞµĞºÑĞ¾Ğ²
// - std::shared_lock - Ğ´Ğ»Ñ shared_mutex (Ğ¼Ğ½Ğ¾Ğ¶ĞµÑÑ‚Ğ²ĞµĞ½Ğ½Ñ‹Ğµ Ñ‡Ğ¸Ñ‚Ğ°Ñ‚ĞµĞ»Ğ¸)

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// âŒ ĞŸĞ›ĞĞ¥Ğ: Ğ“Ğ¾Ğ½ĞºĞ° Ğ·Ğ° Ğ´Ğ°Ğ½Ğ½Ñ‹Ğ¼Ğ¸ Ñ condition_variable
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

std::mutex cv_mutex;
std::condition_variable cv;
bool ready = false;

// ĞŸĞ¾Ñ‚Ğ¾Ğº 1:
// {
//     std::unique_lock lock(cv_mutex);
//     ready = true;
//     lock.unlock();  // âš ï¸ Ğ Ğ°Ğ·Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ»Ğ¸ Ğ”Ğ notify!
// }
// cv.notify_one();  // Ğ”Ñ€ÑƒĞ³Ğ¾Ğ¹ Ğ¿Ğ¾Ñ‚Ğ¾Ğº Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ğ¿Ñ€Ğ¾Ğ¿ÑƒÑÑ‚Ğ¸Ñ‚ÑŒ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ!

// ĞŸĞ¾Ñ‚Ğ¾Ğº 2:
// std::unique_lock lock(cv_mutex);
// cv.wait(lock, [] { return ready; });  // ĞœĞ¾Ğ¶ĞµÑ‚ Ğ·Ğ°ÑĞ½ÑƒÑ‚ÑŒ Ğ½Ğ°Ğ²ĞµÑ‡Ğ½Ğ¾

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// âœ… Ğ¥ĞĞ ĞĞ¨Ğ: ĞŸÑ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ğ¾Ğµ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ condition_variable
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

std::mutex good_mutex;
std::condition_variable good_cv;
bool data_ready = false;

// ĞŸĞ¾Ñ‚Ğ¾Ğº Ğ¿Ñ€Ğ¾Ğ¸Ğ·Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ÑŒ:
// {
//     std::lock_guard lock(good_mutex);
//     data_ready = true;
//     // Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ÑĞµĞ¼ Ğ’ĞĞ£Ğ¢Ğ Ğ˜ Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²ĞºĞ¸ (Ğ¸Ğ»Ğ¸ ÑÑ€Ğ°Ğ·Ñƒ Ğ¿Ğ¾ÑĞ»Ğµ)
//     good_cv.notify_one();
// }

// ĞŸĞ¾Ñ‚Ğ¾Ğº Ğ¿Ğ¾Ñ‚Ñ€ĞµĞ±Ğ¸Ñ‚ĞµĞ»ÑŒ:
// std::unique_lock lock(good_mutex);
// good_cv.wait(lock, [] { return data_ready; });
// // ĞŸÑ€ĞµĞ´Ğ¸ĞºĞ°Ñ‚ Ğ·Ğ°Ñ‰Ğ¸Ñ‰Ğ°ĞµÑ‚ Ğ¾Ñ‚ spurious wakeups
// // Ğ¢ĞµĞ¿ĞµÑ€ÑŒ Ğ¼Ğ¾Ğ¶ĞµĞ¼ Ğ±ĞµĞ·Ğ¾Ğ¿Ğ°ÑĞ½Ğ¾ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°Ñ‚ÑŒ Ñ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğ¼Ğ¸

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// âŒ ĞŸĞ›ĞĞ¥Ğ: ĞĞµĞ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ğ¾Ğµ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ std::async
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// for (int i = 0; i < 1000; ++i) {
//     std::async(std::launch::async, [i]() {
//         // Ğ”Ğ¾Ğ»Ğ³Ğ°Ñ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°
//     });  // âš ï¸ Temporary future ÑÑ€Ğ°Ğ·Ñƒ ÑƒĞ½Ğ¸Ñ‡Ñ‚Ğ¾Ğ¶Ğ°ĞµÑ‚ÑÑ!
//          // Ğ‘Ğ»Ğ¾ĞºĞ¸Ñ€ÑƒĞµÑ‚ Ğ´Ğ¾ Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ¸Ñ Ğ·Ğ°Ğ´Ğ°Ñ‡Ğ¸ - Ğ½ĞµÑ‚ Ğ¿Ğ°Ñ€Ğ°Ğ»Ğ»ĞµĞ»Ğ¸Ğ·Ğ¼Ğ°!
// }

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// âœ… Ğ¥ĞĞ ĞĞ¨Ğ: Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ÑĞ¹Ñ‚Ğµ future Ğ¸Ğ»Ğ¸ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ thread pool
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// std::vector<std::future<void>> futures;
// for (int i = 0; i < 1000; ++i) {
//     futures.push_back(std::async(std::launch::async, [i]() {
//         // Ğ”Ğ¾Ğ»Ğ³Ğ°Ñ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°
//     }));
// }
// 
// // Ğ”Ğ¾Ğ¶Ğ¸Ğ´Ğ°ĞµĞ¼ÑÑ Ğ²ÑĞµÑ…
// for (auto& f : futures) {
//     f.get();
// }

// Ğ˜Ğ»Ğ¸ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ Ğ³Ğ¾Ñ‚Ğ¾Ğ²Ñ‹Ğ¹ thread pool (Ğ½Ğ°Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€, Ğ¸Ğ· Ğ±Ğ¸Ğ±Ğ»Ğ¸Ğ¾Ñ‚ĞµĞºĞ¸)


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“Œ TEMPLATE ANTI-PATTERNS (ĞĞĞ¢Ğ˜ĞŸĞĞ¢Ğ¢Ğ•Ğ ĞĞ« Ğ¨ĞĞ‘Ğ›ĞĞĞĞ’)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// âŒ ĞŸĞ›ĞĞ¥Ğ: Template bloat - Ğ³ĞµĞ½ĞµÑ€Ğ°Ñ†Ğ¸Ñ ĞºĞ¾Ğ´Ğ° Ğ´Ğ»Ñ ĞºĞ°Ğ¶Ğ´Ğ¾Ğ³Ğ¾ Ñ‚Ğ¸Ğ¿Ğ°
template<typename T>
class BadContainer {
    std::vector<T> data_;
    
    // ĞœĞ½Ğ¾Ğ³Ğ¾ ĞºĞ¾Ğ´Ğ°, ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğ¹ Ğ½Ğµ Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ñ‚ Ğ¾Ñ‚ T
    void log_size() {
        std::cout << "Size: " << data_.size() << '\n';
    }
    
    void log_capacity() {
        std::cout << "Capacity: " << data_.capacity() << '\n';
    }
    
    // ... ĞµÑ‰Ğµ 100 Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ğ¹, Ğ½Ğµ Ğ·Ğ°Ğ²Ğ¸ÑÑÑ‰Ğ¸Ñ… Ğ¾Ñ‚ T
    // Ğ’ĞµÑÑŒ ÑÑ‚Ğ¾Ñ‚ ĞºĞ¾Ğ´ Ğ±ÑƒĞ´ĞµÑ‚ Ğ´ÑƒĞ±Ğ»Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒÑÑ Ğ´Ğ»Ñ ĞºĞ°Ğ¶Ğ´Ğ¾Ğ³Ğ¾ T!
};

// âœ… Ğ¥ĞĞ ĞĞ¨Ğ: Ğ’Ñ‹Ğ½ĞµÑĞ¸Ñ‚Ğµ Ğ½Ğµ Ğ·Ğ°Ğ²Ğ¸ÑÑÑ‰Ğ¸Ğ¹ Ğ¾Ñ‚ ÑˆĞ°Ğ±Ğ»Ğ¾Ğ½Ğ° ĞºĞ¾Ğ´ Ğ² Ğ±Ğ°Ğ·Ğ¾Ğ²Ñ‹Ğ¹ ĞºĞ»Ğ°ÑÑ
class ContainerBase {
protected:
    void log_size(size_t size) {
        std::cout << "Size: " << size << '\n';
    }
    
    void log_capacity(size_t capacity) {
        std::cout << "Capacity: " << capacity << '\n';
    }
    
    // ĞšĞ¾Ğ´ ĞºĞ¾Ğ¼Ğ¿Ğ¸Ğ»Ğ¸Ñ€ÑƒĞµÑ‚ÑÑ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ¾Ğ´Ğ¸Ğ½ Ñ€Ğ°Ğ·!
};

template<typename T>
class GoodContainer : private ContainerBase {
    std::vector<T> data_;
    
public:
    void log_info() {
        log_size(data_.size());
        log_capacity(data_.capacity());
    }
};

// âŒ ĞŸĞ›ĞĞ¥Ğ: ĞĞµĞ¿Ğ¾Ğ½ÑÑ‚Ğ½Ñ‹Ğµ Ğ¾ÑˆĞ¸Ğ±ĞºĞ¸ ĞºĞ¾Ğ¼Ğ¿Ğ¸Ğ»ÑÑ†Ğ¸Ğ¸ Ğ±ĞµĞ· concepts
template<typename T>
T bad_add(T a, T b) {
    return a + b;  // Ğ§Ñ‚Ğ¾ ĞµÑĞ»Ğ¸ T Ğ½Ğµ Ğ¿Ğ¾Ğ´Ğ´ĞµÑ€Ğ¶Ğ¸Ğ²Ğ°ĞµÑ‚ operator+?
}

// Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ: bad_add(std::vector<int>{}, std::vector<int>{});
// ĞÑˆĞ¸Ğ±ĞºĞ°: ÑÑ‚Ñ€Ğ°Ğ½Ğ¸Ñ†Ğ° Ğ½ĞµĞ¿Ğ¾Ğ½ÑÑ‚Ğ½Ğ¾Ğ³Ğ¾ Ñ‚ĞµĞºÑÑ‚Ğ° Ğ¿Ñ€Ğ¾ std::vector Ğ¸ operator+

// âœ… Ğ¥ĞĞ ĞĞ¨Ğ: Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ concepts Ğ´Ğ»Ñ Ğ¿Ğ¾Ğ½ÑÑ‚Ğ½Ñ‹Ñ… Ğ¾ÑˆĞ¸Ğ±Ğ¾Ğº (C++20)
template<typename T>
concept Addable = requires(T a, T b) {
    { a + b } -> std::same_as<T>;
};

template<Addable T>
T good_add(T a, T b) {
    return a + b;
}

// Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ: good_add(std::vector<int>{}, std::vector<int>{});
// ĞÑˆĞ¸Ğ±ĞºĞ°: "std::vector<int> Ğ½Ğµ ÑƒĞ´Ğ¾Ğ²Ğ»ĞµÑ‚Ğ²Ğ¾Ñ€ÑĞµÑ‚ ĞºĞ¾Ğ½Ñ†ĞµĞ¿Ñ‚Ñƒ Addable"

// âŒ ĞŸĞ›ĞĞ¥Ğ: Ğ§Ñ€ĞµĞ·Ğ¼ĞµÑ€Ğ½Ğ¾Ğµ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ SFINAE
template<typename T>
typename std::enable_if<std::is_integral<T>::value, T>::type
bad_increment(T value) {
    return value + 1;
}

template<typename T>
typename std::enable_if<!std::is_integral<T>::value, T>::type
bad_increment(T value) {
    return value;  // Ğ”Ğ»Ñ Ğ½Ğµ-Ğ¸Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ğ»ÑŒĞ½Ñ‹Ñ… Ñ‚Ğ¸Ğ¿Ğ¾Ğ²
}

// âœ… Ğ¥ĞĞ ĞĞ¨Ğ: Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ if constexpr (C++17) Ğ¸Ğ»Ğ¸ concepts
template<typename T>
T good_increment(T value) {
    if constexpr (std::is_integral_v<T>) {
        return value + 1;
    } else {
        return value;
    }
}

// Ğ˜Ğ»Ğ¸ Ñ concepts:
template<typename T>
T modern_increment(T value) requires std::integral<T> {
    return value + 1;
}

template<typename T>
T modern_increment(T value) requires (!std::integral<T>) {
    return value;
}


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“Œ PERFORMANCE ANTI-PATTERNS (ĞĞĞ¢Ğ˜ĞŸĞĞ¢Ğ¢Ğ•Ğ ĞĞ« ĞŸĞ ĞĞ˜Ğ—Ğ’ĞĞ”Ğ˜Ğ¢Ğ•Ğ›Ğ¬ĞĞĞ¡Ğ¢Ğ˜)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// âŒ ĞŸĞ›ĞĞ¥Ğ: ĞĞµĞ½ÑƒĞ¶Ğ½Ñ‹Ğµ ĞºĞ¾Ğ¿Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ
void bad_unnecessary_copies() {
    std::vector<std::string> names{"Alice", "Bob", "Charlie"};
    
    // ĞšĞ¾Ğ¿Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ ĞºĞ°Ğ¶Ğ´Ğ¾Ğ¹ ÑÑ‚Ñ€Ğ¾ĞºĞ¸!
    for (std::string name : names) {
        std::cout << name << '\n';
    }
}

// âœ… Ğ¥ĞĞ ĞĞ¨Ğ: Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ const ref
void good_const_ref() {
    std::vector<std::string> names{"Alice", "Bob", "Charlie"};
    
    for (const auto& name : names) {
        std::cout << name << '\n';
    }
}

// âŒ ĞŸĞ›ĞĞ¥Ğ: std::endl Ğ²Ğ¼ĞµÑÑ‚Ğ¾ '\n'
void bad_endl() {
    for (int i = 0; i < 1000; ++i) {
        std::cout << i << std::endl;  // Ğ¡Ğ±Ñ€Ğ¾Ñ Ğ±ÑƒÑ„ĞµÑ€Ğ° Ğ½Ğ° ĞšĞĞ–Ğ”ĞĞ™ Ğ¸Ñ‚ĞµÑ€Ğ°Ñ†Ğ¸Ğ¸!
    }
}

// âœ… Ğ¥ĞĞ ĞĞ¨Ğ: Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ '\n'
void good_newline() {
    for (int i = 0; i < 1000; ++i) {
        std::cout << i << '\n';  // Ğ‘ÑƒÑ„ĞµÑ€ ÑĞ±Ñ€Ğ°ÑÑ‹Ğ²Ğ°ĞµÑ‚ÑÑ ĞºĞ¾Ğ³Ğ´Ğ° Ğ½ÑƒĞ¶Ğ½Ğ¾
    }
    // Ğ¯Ğ²Ğ½Ñ‹Ğ¹ flush Ğ¿Ñ€Ğ¸ Ğ½ĞµĞ¾Ğ±Ñ…Ğ¾Ğ´Ğ¸Ğ¼Ğ¾ÑÑ‚Ğ¸:
    std::cout << std::flush;
}

// âŒ ĞŸĞ›ĞĞ¥Ğ: ĞŸĞµÑ€ĞµĞ´Ğ°Ñ‡Ğ° Ğ±Ğ¾Ğ»ÑŒÑˆĞ¸Ñ… Ğ¾Ğ±ÑŠĞµĞºÑ‚Ğ¾Ğ² Ğ¿Ğ¾ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ñ
struct BigData {
    std::array<double, 1000> values;
};

void bad_pass_by_value(BigData data) {  // ĞšĞ¾Ğ¿Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ 8KB!
    process(data);
}

// âœ… Ğ¥ĞĞ ĞĞ¨Ğ: ĞŸĞµÑ€ĞµĞ´Ğ°Ğ²Ğ°Ğ¹Ñ‚Ğµ Ğ¿Ğ¾ const ref
void good_pass_by_ref(const BigData& data) {  // Ğ‘ĞµĞ· ĞºĞ¾Ğ¿Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ
    process(data);
}

// Ğ˜Ğ»Ğ¸ Ğ¿Ğ¾ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ñ, ĞµÑĞ»Ğ¸ Ğ½ÑƒĞ¶Ğ½Ğ° ĞºĞ¾Ğ¿Ğ¸Ñ Ğ˜ move Ğ´ĞµÑˆĞµĞ²
void good_pass_by_value_when_needed(BigData data) {
    store(std::move(data));  // Ğ˜Ğ·Ğ±ĞµĞ³Ğ°ĞµĞ¼ Ğ»Ğ¸ÑˆĞ½ĞµĞ³Ğ¾ move
}

// âŒ ĞŸĞ›ĞĞ¥Ğ: vector<bool> - ÑĞ¿ĞµÑ†Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ñ Ğ¿Ñ€Ğ¾Ğ±Ğ»ĞµĞ¼Ğ°Ğ¼Ğ¸
void bad_vector_bool() {
    std::vector<bool> flags{true, false, true};
    
    // bool& ref = flags[0];  // ĞĞ• ĞšĞĞœĞŸĞ˜Ğ›Ğ˜Ğ Ğ£Ğ•Ğ¢Ğ¡Ğ¯!
    // vector<bool> Ñ…Ñ€Ğ°Ğ½Ğ¸Ñ‚ Ğ±Ğ¸Ñ‚Ñ‹, Ğ½Ğµ bool'Ñ‹
    
    auto& element = flags[0];  // Ğ­Ñ‚Ğ¾ ĞĞ• bool&, Ğ° Ğ¿Ñ€Ğ¾ĞºÑĞ¸-Ğ¾Ğ±ÑŠĞµĞºÑ‚!
}

// âœ… Ğ¥ĞĞ ĞĞ¨Ğ: Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ vector<char> Ğ¸Ğ»Ğ¸ bitset
void good_bool_alternatives() {
    // Ğ•ÑĞ»Ğ¸ Ğ½ÑƒĞ¶Ğ½Ñ‹ bool'Ñ‹:
    std::vector<char> flags{1, 0, 1};
    bool& ref = reinterpret_cast<bool&>(flags[0]);  // OK
    
    // Ğ•ÑĞ»Ğ¸ Ğ½ÑƒĞ¶ĞµĞ½ Ğ±Ğ¸Ñ‚Ğ¾Ğ²Ñ‹Ğ¹ Ğ¼Ğ°ÑÑĞ¸Ğ² Ñ„Ğ¸ĞºÑĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ğ¾Ğ³Ğ¾ Ñ€Ğ°Ğ·Ğ¼ĞµÑ€Ğ°:
    std::bitset<8> bits;
    bits[0] = true;
    
    // Ğ•ÑĞ»Ğ¸ Ğ½ÑƒĞ¶ĞµĞ½ Ğ´Ğ¸Ğ½Ğ°Ğ¼Ğ¸Ñ‡ĞµÑĞºĞ¸Ğ¹ Ğ±Ğ¸Ñ‚Ğ¾Ğ²Ñ‹Ğ¹ Ğ¼Ğ°ÑÑĞ¸Ğ²:
    // Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ ÑÑ‚Ğ¾Ñ€Ğ¾Ğ½Ğ½Ğ¸Ğµ Ğ±Ğ¸Ğ±Ğ»Ğ¸Ğ¾Ñ‚ĞµĞºĞ¸ Ğ²Ñ€Ğ¾Ğ´Ğµ boost::dynamic_bitset
}

// âŒ ĞŸĞ›ĞĞ¥Ğ: ĞŸÑ€ĞµĞ¶Ğ´ĞµĞ²Ñ€ĞµĞ¼ĞµĞ½Ğ½Ğ°Ñ Ğ¾Ğ¿Ñ‚Ğ¸Ğ¼Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ
void bad_premature_optimization() {
    // "Ğ¯ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒÑ int Ğ²Ğ¼ĞµÑÑ‚Ğ¾ size_t Ğ´Ğ»Ñ ÑĞºĞ¾Ñ€Ğ¾ÑÑ‚Ğ¸"
    for (int i = 0; i < vec.size(); ++i) {  // size() Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµÑ‚ size_t!
        // ĞŸÑ€ĞµĞ´ÑƒĞ¿Ñ€ĞµĞ¶Ğ´ĞµĞ½Ğ¸Ğµ ĞºĞ¾Ğ¼Ğ¿Ğ¸Ğ»ÑÑ‚Ğ¾Ñ€Ğ° + Ğ¿Ğ¾Ñ‚ĞµĞ½Ñ†Ğ¸Ğ°Ğ»ÑŒĞ½Ñ‹Ğµ Ğ¿Ñ€Ğ¾Ğ±Ğ»ĞµĞ¼Ñ‹
    }
    
    // "Ğ¯ Ğ±ÑƒĞ´Ñƒ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ±Ğ¸Ñ‚Ğ¾Ğ²Ñ‹Ğµ Ñ‚Ñ€ÑĞºĞ¸ Ğ´Ğ»Ñ ÑÑĞ½Ğ¾ÑÑ‚Ğ¸"
    int abs_value = (x ^ (x >> 31)) - (x >> 31);  // WTF?
}

// âœ… Ğ¥ĞĞ ĞĞ¨Ğ: Ğ¡Ğ½Ğ°Ñ‡Ğ°Ğ»Ğ° ÑÑĞ½Ğ¾ÑÑ‚ÑŒ, Ğ¿Ğ¾Ñ‚Ğ¾Ğ¼ Ğ¾Ğ¿Ñ‚Ğ¸Ğ¼Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ
void good_clear_code() {
    // Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ñ‹Ğµ Ñ‚Ğ¸Ğ¿Ñ‹
    for (size_t i = 0; i < vec.size(); ++i) {
        // Ğ¯ÑĞ½Ğ¾ Ğ¸ ĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ğ¾
    }
    
    // Ğ˜Ğ»Ğ¸ ĞµÑ‰Ğµ Ğ»ÑƒÑ‡ÑˆĞµ:
    for (const auto& item : vec) {
        // Ğ¡Ğ°Ğ¼Ñ‹Ğ¹ ÑÑĞ½Ñ‹Ğ¹ Ğ²Ğ°Ñ€Ğ¸Ğ°Ğ½Ñ‚
    }
    
    // Ğ¯ÑĞ½Ñ‹Ğ¹ ĞºĞ¾Ğ´ Ğ´Ğ»Ñ Ğ°Ğ±ÑĞ¾Ğ»ÑÑ‚Ğ½Ğ¾Ğ³Ğ¾ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ñ
    int abs_value = std::abs(x);
    
    // ĞĞ¿Ñ‚Ğ¸Ğ¼Ğ¸Ğ·Ğ¸Ñ€ÑƒĞ¹Ñ‚Ğµ Ğ¢ĞĞ›Ğ¬ĞšĞ ĞµÑĞ»Ğ¸ Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¿Ğ¾ĞºĞ°Ğ·Ğ°Ğ»Ğ¾ ÑƒĞ·ĞºĞ¾Ğµ Ğ¼ĞµÑÑ‚Ğ¾!
}


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“Œ MODERN C++ MISUSE (ĞĞ•ĞŸĞ ĞĞ’Ğ˜Ğ›Ğ¬ĞĞĞ• Ğ˜Ğ¡ĞŸĞĞ›Ğ¬Ğ—ĞĞ’ĞĞĞ˜Ğ• Ğ¡ĞĞ’Ğ Ğ•ĞœĞ•ĞĞĞĞ“Ğ C++)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// âŒ ĞŸĞ›ĞĞ¥Ğ: ĞĞµ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ auto Ğ³Ğ´Ğµ Ğ½ÑƒĞ¶Ğ½Ğ¾
void bad_without_auto() {
    std::vector<int> vec{1, 2, 3};
    
    std::vector<int>::iterator it = vec.begin();  // ĞœĞ½Ğ¾Ğ³Ğ¾ÑĞ»Ğ¾Ğ²Ğ½Ğ¾
    
    std::pair<std::string, std::vector<int>> complex_pair;
    std::pair<std::string, std::vector<int>> copy = complex_pair;  // Ğ”ÑƒĞ±Ğ»Ğ¸
}

// âœ… Ğ¥ĞĞ ĞĞ¨Ğ: Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ auto Ğ´Ğ»Ñ Ğ¸Ñ‚ĞµÑ€Ğ°Ñ‚Ğ¾Ñ€Ğ¾Ğ² Ğ¸ ÑĞ»Ğ¾Ğ¶Ğ½Ñ‹Ñ… Ñ‚Ğ¸Ğ¿Ğ¾Ğ²
void good_with_auto() {
    std::vector<int> vec{1, 2, 3};
    
    auto it = vec.begin();  // Ğ¯ÑĞ½Ğ¾ Ğ¸ ĞºÑ€Ğ°Ñ‚ĞºĞ¾
    
    std::pair<std::string, std::vector<int>> complex_pair;
    auto copy = complex_pair;  // DRY Ğ¿Ñ€Ğ¸Ğ½Ñ†Ğ¸Ğ¿
}

// âŒ ĞŸĞ›ĞĞ¥Ğ: ĞĞµ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ range-based for
void bad_index_loop() {
    std::vector<std::string> names{"Alice", "Bob", "Charlie"};
    
    for (size_t i = 0; i < names.size(); ++i) {
        std::cout << names[i] << '\n';
    }
}

// âœ… Ğ¥ĞĞ ĞĞ¨Ğ: Range-based for Ğ´Ğ»Ñ Ğ¸Ñ‚ĞµÑ€Ğ°Ñ†Ğ¸Ğ¸
void good_range_for() {
    std::vector<std::string> names{"Alice", "Bob", "Charlie"};
    
    for (const auto& name : names) {
        std::cout << name << '\n';
    }
}

// âŒ ĞŸĞ›ĞĞ¥Ğ: ĞĞµ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ std::optional Ğ´Ğ»Ñ nullable Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğ¹
std::string* bad_find_user(int id) {
    if (user_exists(id)) {
        return new std::string(get_user_name(id));  // Ğ£Ñ‚ĞµÑ‡ĞºĞ° Ğ¿Ğ°Ğ¼ÑÑ‚Ğ¸!
    }
    return nullptr;
}

// âœ… Ğ¥ĞĞ ĞĞ¨Ğ: Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ std::optional (C++17)
std::optional<std::string> good_find_user(int id) {
    if (user_exists(id)) {
        return get_user_name(id);
    }
    return std::nullopt;
}

// Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ:
void use_optional() {
    if (auto user = good_find_user(42)) {
        std::cout << "User: " << *user << '\n';
    } else {
        std::cout << "User not found\n";
    }
}

// âŒ ĞŸĞ›ĞĞ¥Ğ: Ğ¡Ñ‹Ñ€Ñ‹Ğµ Ñ†Ğ¸ĞºĞ»Ñ‹ Ğ²Ğ¼ĞµÑÑ‚Ğ¾ Ğ°Ğ»Ğ³Ğ¾Ñ€Ğ¸Ñ‚Ğ¼Ğ¾Ğ²
void bad_raw_loops() {
    std::vector<int> numbers{1, 2, 3, 4, 5};
    
    // ĞŸĞ¾Ğ´ÑÑ‡ĞµÑ‚ Ñ‡ĞµÑ‚Ğ½Ñ‹Ñ… Ñ‡Ğ¸ÑĞµĞ»
    int count = 0;
    for (int n : numbers) {
        if (n % 2 == 0) {
            ++count;
        }
    }
    
    // ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ°, Ğ²ÑĞµ Ğ»Ğ¸ Ğ¿Ğ¾Ğ»Ğ¾Ğ¶Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ğµ
    bool all_positive = true;
    for (int n : numbers) {
        if (n <= 0) {
            all_positive = false;
            break;
        }
    }
}

// âœ… Ğ¥ĞĞ ĞĞ¨Ğ: Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ Ğ°Ğ»Ğ³Ğ¾Ñ€Ğ¸Ñ‚Ğ¼Ñ‹ STL
void good_algorithms() {
    std::vector<int> numbers{1, 2, 3, 4, 5};
    
    // ĞŸĞ¾Ğ´ÑÑ‡ĞµÑ‚ Ñ‡ĞµÑ‚Ğ½Ñ‹Ñ… Ñ‡Ğ¸ÑĞµĞ»
    auto count = std::ranges::count_if(numbers, 
        [](int n) { return n % 2 == 0; });
    
    // ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ°, Ğ²ÑĞµ Ğ»Ğ¸ Ğ¿Ğ¾Ğ»Ğ¾Ğ¶Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ğµ
    bool all_positive = std::ranges::all_of(numbers,
        [](int n) { return n > 0; });
}

// âŒ ĞŸĞ›ĞĞ¥Ğ: Ğ˜Ğ³Ğ½Ğ¾Ñ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ std::expected (C++23)
std::pair<int, bool> bad_parse_int(const std::string& s) {
    try {
        return {std::stoi(s), true};
    } catch (...) {
        return {0, false};  // ĞŸĞ¾Ñ‚ĞµÑ€Ñ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ğ¸ Ğ¾Ğ± Ğ¾ÑˆĞ¸Ğ±ĞºĞµ!
    }
}

// âœ… Ğ¥ĞĞ ĞĞ¨Ğ: Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ std::expected (C++23)
/*
std::expected<int, std::string> good_parse_int(const std::string& s) {
    try {
        return std::stoi(s);
    } catch (const std::exception& e) {
        return std::unexpected(e.what());  // Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ÑĞµĞ¼ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ
    }
}

// Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ:
void use_expected() {
    auto result = good_parse_int("123");
    if (result) {
        std::cout << "Parsed: " << *result << '\n';
    } else {
        std::cout << "Error: " << result.error() << '\n';
    }
}
*/


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“Œ API DESIGN ANTI-PATTERNS (ĞĞĞ¢Ğ˜ĞŸĞĞ¢Ğ¢Ğ•Ğ ĞĞ« Ğ”Ğ˜Ğ—ĞĞ™ĞĞ API)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// âŒ ĞŸĞ›ĞĞ¥Ğ: Boolean Ğ¿Ğ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€Ñ‹ Ğ½ĞµÑÑĞ½Ñ‹ Ğ² Ğ¼ĞµÑÑ‚Ğµ Ğ²Ñ‹Ğ·Ğ¾Ğ²Ğ°
void bad_set_visibility(bool visible) {
    // Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ: bad_set_visibility(true);
    // Ğ§Ñ‚Ğ¾ Ğ·Ğ½Ğ°Ñ‡Ğ¸Ñ‚ true? ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ Ğ¸Ğ»Ğ¸ ÑĞºÑ€Ñ‹Ñ‚ÑŒ?
}

// âœ… Ğ¥ĞĞ ĞĞ¨Ğ: Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ enum Ğ´Ğ»Ñ ÑÑĞ½Ğ¾ÑÑ‚Ğ¸
enum class Visibility {
    Visible,
    Hidden
};

void good_set_visibility(Visibility vis) {
    // Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ: good_set_visibility(Visibility::Visible);
    // ĞšÑ€Ğ¸ÑÑ‚Ğ°Ğ»ÑŒĞ½Ğ¾ ÑÑĞ½Ğ¾!
}

// âŒ ĞŸĞ›ĞĞ¥Ğ: Out-Ğ¿Ğ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€Ñ‹ Ğ²Ğ¼ĞµÑÑ‚Ğ¾ Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‚Ğ° Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğ¹
void bad_calculate(int a, int b, int& sum, int& product) {
    sum = a + b;
    product = a * b;
}

// âœ… Ğ¥ĞĞ ĞĞ¨Ğ: Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°Ğ¹Ñ‚Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ñ
struct CalculationResult {
    int sum;
    int product;
};

CalculationResult good_calculate(int a, int b) {
    return {a + b, a * b};
}

// Ğ˜Ğ»Ğ¸ Ñ structured bindings (C++17):
std::pair<int, int> modern_calculate(int a, int b) {
    return {a + b, a * b};
}

void use_modern_calculate() {
    auto [sum, product] = modern_calculate(5, 10);
}

// âŒ ĞŸĞ›ĞĞ¥Ğ: Ğ¡Ğ¼ĞµÑˆĞ¸Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¾Ñ‚Ğ²ĞµÑ‚ÑÑ‚Ğ²ĞµĞ½Ğ½Ğ¾ÑÑ‚ĞµĞ¹ Ğ² Ğ¾Ğ´Ğ½Ğ¾Ğ¹ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ğ¸
void bad_process_and_save_user(const std::string& name, const std::string& email) {
    // Ğ’Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ†Ğ¸Ñ
    if (name.empty() || email.empty()) {
        throw std::invalid_argument("Invalid input");
    }
    
    // Ğ‘Ğ¸Ğ·Ğ½ĞµÑ-Ğ»Ğ¾Ğ³Ğ¸ĞºĞ°
    User user = create_user(name, email);
    validate_user(user);
    
    // Ğ‘Ğ°Ğ·Ğ° Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…
    save_to_database(user);
    
    // ĞÑ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ° email
    send_welcome_email(user);
    
    // Ğ›Ğ¾Ğ³Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ
    log("User created: " + name);
}

// âœ… Ğ¥ĞĞ ĞĞ¨Ğ: Ğ Ğ°Ğ·Ğ´ĞµĞ»Ğ¸Ñ‚Ğµ Ğ¾Ñ‚Ğ²ĞµÑ‚ÑÑ‚Ğ²ĞµĞ½Ğ½Ğ¾ÑÑ‚Ğ¸
User good_create_user(const std::string& name, const std::string& email) {
    if (name.empty() || email.empty()) {
        throw std::invalid_argument("Invalid input");
    }
    return create_user(name, email);
}

void good_save_user(const User& user) {
    save_to_database(user);
}

void good_notify_user(const User& user) {
    send_welcome_email(user);
}

// ĞšĞ¾Ğ¼Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ñ Ğ² Ğ²Ñ‹ÑĞ¾ĞºĞ¾ÑƒÑ€Ğ¾Ğ²Ğ½ĞµĞ²Ğ¾Ğ¹ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ğ¸:
void good_register_user(const std::string& name, const std::string& email) {
    auto user = good_create_user(name, email);
    good_save_user(user);
    good_notify_user(user);
}

// âŒ ĞŸĞ›ĞĞ¥Ğ: God Object - Ğ¾Ğ±ÑŠĞµĞºÑ‚, Ğ·Ğ½Ğ°ÑÑ‰Ğ¸Ğ¹/Ğ´ĞµĞ»Ğ°ÑÑ‰Ğ¸Ğ¹ ÑĞ»Ğ¸ÑˆĞºĞ¾Ğ¼ Ğ¼Ğ½Ğ¾Ğ³Ğ¾
class BadUserManager {
    // Ğ‘Ğ°Ğ·Ğ° Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…
    void save_to_db(const User& user);
    void load_from_db(int id);
    void delete_from_db(int id);
    
    // Ğ’Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ†Ğ¸Ñ
    bool validate_email(const std::string& email);
    bool validate_name(const std::string& name);
    
    // Email
    void send_email(const User& user);
    void send_password_reset(const User& user);
    
    // ĞÑƒÑ‚ĞµĞ½Ñ‚Ğ¸Ñ„Ğ¸ĞºĞ°Ñ†Ğ¸Ñ
    bool authenticate(const std::string& username, const std::string& password);
    
    // ĞĞ²Ñ‚Ğ¾Ñ€Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ
    bool has_permission(const User& user, const std::string& resource);
    
    // Ğ›Ğ¾Ğ³Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ
    void log(const std::string& message);
    
    // Ğ˜ ĞµÑ‰Ğµ 50 Ğ¼ĞµÑ‚Ğ¾Ğ´Ğ¾Ğ²...
};

// âœ… Ğ¥ĞĞ ĞĞ¨Ğ: Ğ Ğ°Ğ·Ğ´ĞµĞ»Ğ¸Ñ‚Ğµ Ğ¾Ñ‚Ğ²ĞµÑ‚ÑÑ‚Ğ²ĞµĞ½Ğ½Ğ¾ÑÑ‚Ğ¸ Ğ½Ğ° Ğ¾Ñ‚Ğ´ĞµĞ»ÑŒĞ½Ñ‹Ğµ ĞºĞ»Ğ°ÑÑÑ‹
class UserRepository {
    void save(const User& user);
    User load(int id);
    void remove(int id);
};

class UserValidator {
    bool validate_email(const std::string& email);
    bool validate_name(const std::string& name);
};

class EmailService {
    void send(const User& user, const std::string& message);
};

class AuthenticationService {
    bool authenticate(const std::string& username, const std::string& password);
};

class AuthorizationService {
    bool has_permission(const User& user, const std::string& resource);
};


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“Œ CODE SMELL PATTERNS (ĞŸĞĞ¢Ğ¢Ğ•Ğ ĞĞ« "Ğ—ĞĞŸĞĞ¥ĞĞ’" ĞšĞĞ”Ğ)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// âŒ ĞŸĞ›ĞĞ¥Ğ: Magic numbers
void bad_magic_numbers() {
    if (age >= 18) {  // Ğ§Ñ‚Ğ¾ Ğ·Ğ½Ğ°Ñ‡Ğ¸Ñ‚ 18?
        grant_access();
    }
    
    double tax = price * 0.15;  // Ğ§Ñ‚Ğ¾ Ğ·Ğ° 0.15?
    
    for (int i = 0; i < 7; ++i) {  // ĞŸĞ¾Ñ‡ĞµĞ¼Ñƒ 7?
        process_day(i);
    }
}

// âœ… Ğ¥ĞĞ ĞĞ¨Ğ: Ğ˜Ğ¼ĞµĞ½Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğµ ĞºĞ¾Ğ½ÑÑ‚Ğ°Ğ½Ñ‚Ñ‹
void good_named_constants() {
    constexpr int LEGAL_AGE = 18;
    constexpr double TAX_RATE = 0.15;
    constexpr int DAYS_IN_WEEK = 7;
    
    if (age >= LEGAL_AGE) {
        grant_access();
    }
    
    double tax = price * TAX_RATE;
    
    for (int day = 0; day < DAYS_IN_WEEK; ++day) {
        process_day(day);
    }
}

// âŒ ĞŸĞ›ĞĞ¥Ğ: Ğ“Ğ»ÑƒĞ±Ğ¾ĞºĞ°Ñ Ğ²Ğ»Ğ¾Ğ¶ĞµĞ½Ğ½Ğ¾ÑÑ‚ÑŒ
void bad_deep_nesting(const User& user) {
    if (user.is_authenticated()) {
        if (user.has_permission("write")) {
            if (user.has_quota()) {
                if (validate_input(user.input())) {
                    if (check_rate_limit(user)) {
                        // ĞĞ°ĞºĞ¾Ğ½ĞµÑ†-Ñ‚Ğ¾ Ğ½Ğ°ÑÑ‚Ğ¾ÑÑ‰Ğ°Ñ Ğ»Ğ¾Ğ³Ğ¸ĞºĞ°!
                        process(user);
                    } else {
                        log_rate_limit_exceeded();
                    }
                } else {
                    log_invalid_input();
                }
            } else {
                log_quota_exceeded();
            }
        } else {
            log_no_permission();
        }
    } else {
        log_not_authenticated();
    }
}

// âœ… Ğ¥ĞĞ ĞĞ¨Ğ: Early returns Ğ´Ğ»Ñ ÑƒĞ¼ĞµĞ½ÑŒÑˆĞµĞ½Ğ¸Ñ Ğ²Ğ»Ğ¾Ğ¶ĞµĞ½Ğ½Ğ¾ÑÑ‚Ğ¸
void good_early_returns(const User& user) {
    if (!user.is_authenticated()) {
        log_not_authenticated();
        return;
    }
    
    if (!user.has_permission("write")) {
        log_no_permission();
        return;
    }
    
    if (!user.has_quota()) {
        log_quota_exceeded();
        return;
    }
    
    if (!validate_input(user.input())) {
        log_invalid_input();
        return;
    }
    
    if (!check_rate_limit(user)) {
        log_rate_limit_exceeded();
        return;
    }
    
    // ĞĞ°ÑÑ‚Ğ¾ÑÑ‰Ğ°Ñ Ğ»Ğ¾Ğ³Ğ¸ĞºĞ° Ğ½Ğ° Ğ²ĞµÑ€Ñ…Ğ½ĞµĞ¼ ÑƒÑ€Ğ¾Ğ²Ğ½Ğµ
    process(user);
}

// âŒ ĞŸĞ›ĞĞ¥Ğ: Ğ”Ğ»Ğ¸Ğ½Ğ½Ñ‹Ğµ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ğ¸ (100+ ÑÑ‚Ñ€Ğ¾Ğº)
void bad_long_function() {
    // Ğ˜Ğ½Ğ¸Ñ†Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ (20 ÑÑ‚Ñ€Ğ¾Ğº)
    // ...
    
    // Ğ’Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ†Ğ¸Ñ (30 ÑÑ‚Ñ€Ğ¾Ğº)
    // ...
    
    // ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° (40 ÑÑ‚Ñ€Ğ¾Ğº)
    // ...
    
    // Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ğµ (20 ÑÑ‚Ñ€Ğ¾Ğº)
    // ...
    
    // ĞÑ‡Ğ¸ÑÑ‚ĞºĞ° (10 ÑÑ‚Ñ€Ğ¾Ğº)
    // ...
}

// âœ… Ğ¥ĞĞ ĞĞ¨Ğ: Ğ Ğ°Ğ·Ğ±Ğ¸Ğ²ĞºĞ° Ğ½Ğ° Ğ¼Ğ°Ğ»ĞµĞ½ÑŒĞºĞ¸Ğµ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ğ¸
void good_decomposed_function() {
    initialize();
    validate();
    process();
    save();
    cleanup();
}

// âŒ ĞŸĞ›ĞĞ¥Ğ: Ğ”ÑƒĞ±Ğ»Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ ĞºĞ¾Ğ´Ğ°
void bad_process_user_data() {
    std::string name = user_input["name"];
    name.erase(0, name.find_first_not_of(" \t"));
    name.erase(name.find_last_not_of(" \t") + 1);
    
    std::string email = user_input["email"];
    email.erase(0, email.find_first_not_of(" \t"));
    email.erase(email.find_last_not_of(" \t") + 1);
    
    std::string phone = user_input["phone"];
    phone.erase(0, phone.find_first_not_of(" \t"));
    phone.erase(phone.find_last_not_of(" \t") + 1);
}

// âœ… Ğ¥ĞĞ ĞĞ¨Ğ: DRY - Don't Repeat Yourself
std::string trim(std::string s) {
    s.erase(0, s.find_first_not_of(" \t"));
    s.erase(s.find_last_not_of(" \t") + 1);
    return s;
}

void good_process_user_data() {
    std::string name = trim(user_input["name"]);
    std::string email = trim(user_input["email"]);
    std::string phone = trim(user_input["phone"]);
}

// âŒ ĞŸĞ›ĞĞ¥Ğ: Ğ—Ğ°ĞºĞ¾Ğ¼Ğ¼ĞµĞ½Ñ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğ¹ ĞºĞ¾Ğ´
void bad_with_commented_code() {
    process_data();
    
    // Old implementation - don't delete, might need later
    // for (int i = 0; i < data.size(); ++i) {
    //     process(data[i]);
    // }
    
    // Legacy code
    // old_process();
    // legacy_cleanup();
    
    save_result();
}

// âœ… Ğ¥ĞĞ ĞĞ¨Ğ: Ğ£Ğ´Ğ°Ğ»ÑĞ¹Ñ‚Ğµ Ğ¼ĞµÑ€Ñ‚Ğ²Ñ‹Ğ¹ ĞºĞ¾Ğ´ (Ñƒ Ğ²Ğ°Ñ ĞµÑÑ‚ÑŒ Git!)
void good_clean_code() {
    process_data();
    save_result();
    // Ğ¡Ñ‚Ğ°Ñ€Ñ‹Ğ¹ ĞºĞ¾Ğ´ Ğ² Ğ¸ÑÑ‚Ğ¾Ñ€Ğ¸Ğ¸ Git, ĞµÑĞ»Ğ¸ Ğ¿Ğ¾Ğ½Ğ°Ğ´Ğ¾Ğ±Ğ¸Ñ‚ÑÑ
}


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“Œ UNDEFINED BEHAVIOR TRAPS (Ğ›ĞĞ’Ğ£Ğ¨ĞšĞ˜ ĞĞ•ĞĞŸĞ Ğ•Ğ”Ğ•Ğ›ĞĞĞĞĞ“Ğ ĞŸĞĞ’Ğ•Ğ”Ğ•ĞĞ˜Ğ¯)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// âŒ ĞŸĞ›ĞĞ¥Ğ: Signed integer overflow
void bad_signed_overflow() {
    int max_int = std::numeric_limits<int>::max();
    int overflow = max_int + 1;  // UNDEFINED BEHAVIOR!
    // ĞœĞ¾Ğ¶ĞµÑ‚ Ğ±Ñ‹Ñ‚ÑŒ Ñ‡Ñ‚Ğ¾ ÑƒĞ³Ğ¾Ğ´Ğ½Ğ¾
}

// âœ… Ğ¥ĞĞ ĞĞ¨Ğ: Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ unsigned Ğ¸Ğ»Ğ¸ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ÑĞ¹Ñ‚Ğµ
void good_overflow_handling() {
    unsigned int max_uint = std::numeric_limits<unsigned int>::max();
    unsigned int overflow = max_uint + 1;  // ĞĞ¿Ñ€ĞµĞ´ĞµĞ»ĞµĞ½Ğ½Ğ¾Ğµ Ğ¿Ğ¾Ğ²ĞµĞ´ĞµĞ½Ğ¸Ğµ: 0
    
    // Ğ˜Ğ»Ğ¸ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ÑĞ¹Ñ‚Ğµ Ğ¿ĞµÑ€ĞµĞ´ Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸ĞµĞ¹:
    int a = 1000000, b = 1000000;
    if (a > std::numeric_limits<int>::max() - b) {
        // ĞŸĞµÑ€ĞµĞ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ğµ!
        throw std::overflow_error("Integer overflow");
    }
    int sum = a + b;
}

// âŒ ĞŸĞ›ĞĞ¥Ğ: Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ½ĞµĞ¸Ğ½Ğ¸Ñ†Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ñ… Ğ¿ĞµÑ€ĞµĞ¼ĞµĞ½Ğ½Ñ‹Ñ…
void bad_uninitialized() {
    int x;  // ĞĞµĞ¸Ğ½Ğ¸Ñ†Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½!
    std::cout << x << '\n';  // UNDEFINED BEHAVIOR!
    
    int* ptr;  // ĞĞµĞ¸Ğ½Ğ¸Ñ†Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½!
    *ptr = 42;  // UNDEFINED BEHAVIOR!
}

// âœ… Ğ¥ĞĞ ĞĞ¨Ğ: Ğ’ÑĞµĞ³Ğ´Ğ° Ğ¸Ğ½Ğ¸Ñ†Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ¸Ñ€ÑƒĞ¹Ñ‚Ğµ Ğ¿ĞµÑ€ĞµĞ¼ĞµĞ½Ğ½Ñ‹Ğµ
void good_initialized() {
    int x = 0;  // Ğ˜Ğ»Ğ¸ Ğ´Ñ€ÑƒĞ³Ğ¾Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾ ÑƒĞ¼Ğ¾Ğ»Ñ‡Ğ°Ğ½Ğ¸Ñ
    std::cout << x << '\n';  // OK
    
    int* ptr = nullptr;
    if (ptr) {  // ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ¿ĞµÑ€ĞµĞ´ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸ĞµĞ¼
        *ptr = 42;
    }
}

// âŒ ĞŸĞ›ĞĞ¥Ğ: Ğ’Ğ¸ÑÑÑ‡Ğ¸Ğµ ÑÑÑ‹Ğ»ĞºĞ¸
const std::string& bad_dangling_reference() {
    std::string temp = "Hello";
    return temp;  // UNDEFINED BEHAVIOR! temp ÑƒĞ½Ğ¸Ñ‡Ñ‚Ğ¾Ğ¶Ğ°ĞµÑ‚ÑÑ
}

void bad_use_dangling() {
    const std::string& ref = bad_dangling_reference();
    std::cout << ref << '\n';  // ĞĞ±Ñ€Ğ°Ñ‰ĞµĞ½Ğ¸Ğµ Ğº ÑƒĞ½Ğ¸Ñ‡Ñ‚Ğ¾Ğ¶ĞµĞ½Ğ½Ğ¾Ğ¼Ñƒ Ğ¾Ğ±ÑŠĞµĞºÑ‚Ñƒ!
}

// âœ… Ğ¥ĞĞ ĞĞ¨Ğ: Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°Ğ¹Ñ‚Ğµ Ğ¿Ğ¾ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ñ (RVO Ğ¾Ğ¿Ñ‚Ğ¸Ğ¼Ğ¸Ğ·Ğ¸Ñ€ÑƒĞµÑ‚)
std::string good_return_by_value() {
    std::string temp = "Hello";
    return temp;  // OK, RVO Ğ¸Ğ·Ğ±ĞµĞ¶Ğ¸Ñ‚ ĞºĞ¾Ğ¿Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ
}

// âŒ ĞŸĞ›ĞĞ¥Ğ: Ğ˜Ğ½Ğ²Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ†Ğ¸Ñ Ğ¸Ñ‚ĞµÑ€Ğ°Ñ‚Ğ¾Ñ€Ğ¾Ğ²
void bad_iterator_invalidation() {
    std::vector<int> vec{1, 2, 3, 4, 5};
    
    for (auto it = vec.begin(); it != vec.end(); ++it) {
        if (*it % 2 == 0) {
            vec.erase(it);  // Ğ˜ĞĞ’ĞĞ›Ğ˜Ğ”Ğ˜Ğ Ğ£Ğ•Ğ¢ it!
            // Ğ¡Ğ»ĞµĞ´ÑƒÑÑ‰Ğ¸Ğ¹ ++it - UNDEFINED BEHAVIOR!
        }
    }
}

// âœ… Ğ¥ĞĞ ĞĞ¨Ğ: Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµĞ¼Ñ‹Ğ¹ Ğ¸Ñ‚ĞµÑ€Ğ°Ñ‚Ğ¾Ñ€
void good_iterator_handling() {
    std::vector<int> vec{1, 2, 3, 4, 5};
    
    for (auto it = vec.begin(); it != vec.end(); ) {
        if (*it % 2 == 0) {
            it = vec.erase(it);  // erase Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµÑ‚ ÑĞ»ĞµĞ´ÑƒÑÑ‰Ğ¸Ğ¹ Ğ²Ğ°Ğ»Ğ¸Ğ´Ğ½Ñ‹Ğ¹ Ğ¸Ñ‚ĞµÑ€Ğ°Ñ‚Ğ¾Ñ€
        } else {
            ++it;
        }
    }
    
    // Ğ˜Ğ»Ğ¸ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ erase-remove idiom:
    vec.erase(
        std::remove_if(vec.begin(), vec.end(),
            [](int x) { return x % 2 == 0; }),
        vec.end()
    );
}

// âŒ ĞŸĞ›ĞĞ¥Ğ: ĞœĞ½Ğ¾Ğ¶ĞµÑÑ‚Ğ²ĞµĞ½Ğ½Ñ‹Ğµ Ğ¼Ğ¾Ğ´Ğ¸Ñ„Ğ¸ĞºĞ°Ñ†Ğ¸Ğ¸ Ğ±ĞµĞ· sequence point
void bad_sequence_point() {
    int i = 0;
    int x = i++ + i++;  // UNDEFINED BEHAVIOR!
    // ĞŸĞ¾Ñ€ÑĞ´Ğ¾Ğº Ğ²Ñ‹Ñ‡Ğ¸ÑĞ»ĞµĞ½Ğ¸Ñ Ğ½Ğµ Ğ¾Ğ¿Ñ€ĞµĞ´ĞµĞ»ĞµĞ½
    
    int arr[10];
    int idx = 0;
    arr[idx] = idx++;  // UNDEFINED BEHAVIOR!
}

// âœ… Ğ¥ĞĞ ĞĞ¨Ğ: Ğ Ğ°Ğ·Ğ´ĞµĞ»Ğ¸Ñ‚Ğµ Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸Ğ¸
void good_sequence_points() {
    int i = 0;
    int temp1 = i++;
    int temp2 = i++;
    int x = temp1 + temp2;  // OK
    
    int arr[10];
    int idx = 0;
    arr[idx] = idx;
    ++idx;  // OK
}

// âŒ ĞŸĞ›ĞĞ¥Ğ: ĞĞ±Ñ€Ğ°Ñ‰ĞµĞ½Ğ¸Ğµ Ğº Ğ¼Ğ°ÑÑĞ¸Ğ²Ñƒ Ğ·Ğ° Ğ³Ñ€Ğ°Ğ½Ğ¸Ñ†Ğ°Ğ¼Ğ¸
void bad_out_of_bounds() {
    int arr[5] = {1, 2, 3, 4, 5};
    int value = arr[10];  // UNDEFINED BEHAVIOR!
    
    std::vector<int> vec{1, 2, 3};
    vec[5] = 42;  // UNDEFINED BEHAVIOR!
}

// âœ… Ğ¥ĞĞ ĞĞ¨Ğ: Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ at() Ğ´Ğ»Ñ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ¸ Ğ¸Ğ»Ğ¸ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ÑĞ¹Ñ‚Ğµ Ğ³Ñ€Ğ°Ğ½Ğ¸Ñ†Ñ‹
void good_bounds_checking() {
    int arr[5] = {1, 2, 3, 4, 5};
    int index = 10;
    if (index < 5) {
        int value = arr[index];
    }
    
    std::vector<int> vec{1, 2, 3};
    try {
        vec.at(5) = 42;  // Ğ‘Ñ€Ğ¾ÑĞ¸Ñ‚ std::out_of_range
    } catch (const std::out_of_range&) {
        std::cerr << "Index out of range\n";
    }
}



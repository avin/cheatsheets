/*
 * ============================================
 * Ğ¡ĞĞ’Ğ Ğ•ĞœĞ•ĞĞĞĞ¯ ĞœĞĞĞ“ĞĞŸĞĞ¢ĞĞ§ĞĞĞ¡Ğ¢Ğ¬ C++20/23
 * ============================================
 * 
 * ĞŸĞ¾Ğ»Ğ½Ğ¾Ğµ Ñ€ÑƒĞºĞ¾Ğ²Ğ¾Ğ´ÑÑ‚Ğ²Ğ¾ Ğ¿Ğ¾ Ğ¼Ğ½Ğ¾Ğ³Ğ¾Ğ¿Ğ¾Ñ‚Ğ¾Ñ‡Ğ½Ğ¾Ğ¼Ñƒ Ğ¿Ñ€Ğ¾Ğ³Ñ€Ğ°Ğ¼Ğ¼Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ Ğ² C++
 * Ñ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸ĞµĞ¼ Ğ½Ğ¾Ğ²ĞµĞ¹ÑˆĞ¸Ñ… Ğ²Ğ¾Ğ·Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ÑÑ‚ĞµĞ¹ C++20/23.
 * 
 * Ğ¢Ñ€ĞµĞ±Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ: C++20 Ğ¸Ğ»Ğ¸ Ğ²Ñ‹ÑˆĞµ
 * ĞšĞ¾Ğ¼Ğ¿Ğ¸Ğ»ÑÑ†Ğ¸Ñ: g++ -std=c++20 -pthread concurrency_modern.cpp
 */

#include <thread>
#include <mutex>
#include <shared_mutex>
#include <condition_variable>
#include <semaphore>       // C++20
#include <latch>           // C++20
#include <barrier>         // C++20
#include <stop_token>      // C++20
#include <atomic>
#include <future>
#include <queue>
#include <vector>
#include <iostream>
#include <chrono>
#include <functional>
#include <memory>
#include <syncstream>      // C++20

using namespace std::chrono_literals;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“Œ THREAD BASICS - ĞĞ¡ĞĞĞ’Ğ« ĞŸĞĞ¢ĞĞšĞĞ’
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/*
 * std::thread - Ğ‘ĞĞ—ĞĞ’Ğ«Ğ™ ĞšĞ›ĞĞ¡Ğ¡ Ğ”Ğ›Ğ¯ Ğ¡ĞĞ—Ğ”ĞĞĞ˜Ğ¯ ĞŸĞĞ¢ĞĞšĞĞ’
 * 
 * Ğ’ĞĞ–ĞĞ:
 * - ĞšĞ°Ğ¶Ğ´Ñ‹Ğ¹ Ğ¿Ğ¾Ñ‚Ğ¾Ğº Ğ”ĞĞ›Ğ–Ğ•Ğ Ğ±Ñ‹Ñ‚ÑŒ join() Ğ¸Ğ»Ğ¸ detach() Ğ¿ĞµÑ€ĞµĞ´ Ğ´ĞµÑÑ‚Ñ€ÑƒĞºÑ†Ğ¸ĞµĞ¹
 * - Ğ—Ğ°Ğ±Ñ‹Ğ»Ğ¸ join/detach? â†’ std::terminate()!
 * - Ğ ĞµĞºĞ¾Ğ¼ĞµĞ½Ğ´ÑƒĞµÑ‚ÑÑ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ std::jthread (C++20) Ğ´Ğ»Ñ Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¾Ğ³Ğ¾ join
 */

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ĞŸÑ€Ğ¾ÑÑ‚ĞµĞ¹ÑˆĞ¸Ğ¹ ÑĞ¿Ğ¾ÑĞ¾Ğ± ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ Ğ¿Ğ¾Ñ‚Ğ¾ĞºĞ°
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

std::thread t1([] {
    std::cout << "Hello from thread!\n";
});

t1.join();  // âœ… Ğ–Ğ´ĞµĞ¼ Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ¸Ñ Ğ¿Ğ¾Ñ‚Ğ¾ĞºĞ° (ĞĞ‘Ğ¯Ğ—ĞĞ¢Ğ•Ğ›Ğ¬ĞĞ!)

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ĞŸĞ¾Ñ‚Ğ¾Ğº Ñ Ğ¿Ğ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€Ğ°Ğ¼Ğ¸
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

auto task = [](int id, const std::string& msg) {
    std::cout << "Thread " << id << ": " << msg << '\n';
};

std::thread t2(task, 1, "First thread");
std::thread t3(task, 2, "Second thread");

t2.join();
t3.join();

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// detach() - Ğ¿Ğ¾Ñ‚Ğ¾Ğº Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°ĞµÑ‚ Ğ½ĞµĞ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

std::thread t4([] {
    std::this_thread::sleep_for(100ms);
    std::cout << "Detached thread\n";
});

t4.detach();  // âš ï¸ ĞŸĞ¾Ñ‚Ğ¾Ğº Ğ¾Ñ‚ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½, Ğ¶Ğ¸Ğ²ĞµÑ‚ ÑĞ²Ğ¾ĞµĞ¹ Ğ¶Ğ¸Ğ·Ğ½ÑŒÑ
// ĞŸÑ€Ğ¾Ğ³Ñ€Ğ°Ğ¼Ğ¼Ğ° Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞ¸Ñ‚ÑŒÑÑ Ñ€Ğ°Ğ½ÑŒÑˆĞµ, Ñ‡ĞµĞ¼ t4!

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Ğ˜Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ Ğ¾ ÑĞ¸ÑÑ‚ĞµĞ¼Ğµ Ğ¸ Ğ¿Ğ¾Ñ‚Ğ¾ĞºĞ°Ñ…
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// ĞšĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ Ğ°Ğ¿Ğ¿Ğ°Ñ€Ğ°Ñ‚Ğ½Ñ‹Ñ… Ğ¿Ğ¾Ñ‚Ğ¾ĞºĞ¾Ğ² Ğ¿Ñ€Ğ¾Ñ†ĞµÑÑĞ¾Ñ€Ğ°
unsigned int num_threads = std::thread::hardware_concurrency();
std::cout << "Hardware threads: " << num_threads << '\n';

// ID Ñ‚ĞµĞºÑƒÑ‰ĞµĞ³Ğ¾ Ğ¿Ğ¾Ñ‚Ğ¾ĞºĞ°
auto thread_id = std::this_thread::get_id();
std::cout << "Current thread ID: " << thread_id << '\n';

// Ğ£Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ñ‚ĞµĞºÑƒÑ‰Ğ¸Ğ¼ Ğ¿Ğ¾Ñ‚Ğ¾ĞºĞ¾Ğ¼
std::this_thread::sleep_for(100ms);  // ĞŸÑ€Ğ¸Ğ¾ÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ Ğ¿Ğ¾Ñ‚Ğ¾Ğº Ğ½Ğ° 100 Ğ¼Ñ
std::this_thread::yield();           // ĞŸĞµÑ€ĞµĞ´Ğ°Ñ‚ÑŒ ÑƒĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ´Ñ€ÑƒĞ³Ğ¸Ğ¼ Ğ¿Ğ¾Ñ‚Ğ¾ĞºĞ°Ğ¼

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// âŒ Ğ¢Ğ˜ĞŸĞ˜Ğ§ĞĞ«Ğ• ĞĞ¨Ğ˜Ğ‘ĞšĞ˜
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// âŒ ĞŸĞ›ĞĞ¥Ğ: Ğ·Ğ°Ğ±Ñ‹Ğ»Ğ¸ join/detach
void bad_example() {
    std::thread t([] { std::cout << "Task\n"; });
    // Ğ”ĞµÑÑ‚Ñ€ÑƒĞºÑ‚Ğ¾Ñ€ ~thread() Ğ²Ñ‹Ğ·Ğ¾Ğ²ĞµÑ‚ std::terminate()!
}  // CRASH!

// âœ… Ğ¥ĞĞ ĞĞ¨Ğ: Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµĞ¼ RAII Ğ¾Ğ±ĞµÑ€Ñ‚ĞºÑƒ Ğ¸Ğ»Ğ¸ jthread
void good_example() {
    std::thread t([] { std::cout << "Task\n"; });
    t.join();  // OK
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“Œ std::jthread (C++20) - Ğ£Ğ›Ğ£Ğ§Ğ¨Ğ•ĞĞĞ«Ğ™ ĞŸĞĞ¢ĞĞš Ğ¡ ĞĞ’Ğ¢ĞĞœĞĞ¢Ğ˜Ğ§Ğ•Ğ¡ĞšĞ˜Ğœ JOIN
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/*
 * std::jthread - Ğ¡ĞĞ’Ğ Ğ•ĞœĞ•ĞĞĞĞ¯ Ğ—ĞĞœĞ•ĞĞ std::thread
 * 
 * ĞŸĞ Ğ•Ğ˜ĞœĞ£Ğ©Ğ•Ğ¡Ğ¢Ğ’Ğ:
 * âœ“ ĞĞ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸Ğ¹ join() Ğ² Ğ´ĞµÑÑ‚Ñ€ÑƒĞºÑ‚Ğ¾Ñ€Ğµ
 * âœ“ Ğ’ÑÑ‚Ñ€Ğ¾ĞµĞ½Ğ½Ğ°Ñ Ğ¿Ğ¾Ğ´Ğ´ĞµÑ€Ğ¶ĞºĞ° stop_token (ĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ğ°Ñ Ğ¾ÑÑ‚Ğ°Ğ½Ğ¾Ğ²ĞºĞ°)
 * âœ“ Ğ‘ĞµĞ·Ğ¾Ğ¿Ğ°ÑĞ½ĞµĞµ Ğ¸ ÑƒĞ´Ğ¾Ğ±Ğ½ĞµĞµ Ñ‡ĞµĞ¼ std::thread
 * 
 * Ğ Ğ•ĞšĞĞœĞ•ĞĞ”ĞĞ¦Ğ˜Ğ¯: Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ jthread Ğ²Ğ¼ĞµÑÑ‚Ğ¾ thread Ğ² Ğ½Ğ¾Ğ²Ğ¾Ğ¼ ĞºĞ¾Ğ´Ğµ!
 */

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ĞĞ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸Ğ¹ join Ğ¿Ñ€Ğ¸ Ğ²Ñ‹Ñ…Ğ¾Ğ´Ğµ Ğ¸Ğ· scope
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

{
    std::jthread t([] {
        std::cout << "jthread: Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸Ğ¹ join Ğ¿Ñ€Ğ¸ Ğ²Ñ‹Ñ…Ğ¾Ğ´Ğµ Ğ¸Ğ· scope\n";
    });
    // ĞĞµ Ğ½ÑƒĞ¶ĞµĞ½ ÑĞ²Ğ½Ñ‹Ğ¹ join - Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ÑÑ Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸ Ğ¿Ñ€Ğ¸ Ğ´ĞµÑÑ‚Ñ€ÑƒĞºÑ†Ğ¸Ğ¸!
}  // âœ… Ğ—Ğ´ĞµÑÑŒ Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸ Ğ²Ñ‹Ğ·Ğ¾Ğ²ĞµÑ‚ÑÑ join()

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// jthread Ñ stop_token - ĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ğ°Ñ Ğ¾ÑÑ‚Ğ°Ğ½Ğ¾Ğ²ĞºĞ° Ğ¿Ğ¾Ñ‚Ğ¾ĞºĞ°
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

std::jthread worker([](std::stop_token stoken) {
    int count = 0;
    
    // ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ·Ğ°Ğ¿Ñ€Ğ¾Ñ Ğ½Ğ° Ğ¾ÑÑ‚Ğ°Ğ½Ğ¾Ğ²ĞºÑƒ
    while (!stoken.stop_requested()) {
        std::cout << "Working... " << count++ << '\n';
        std::this_thread::sleep_for(100ms);
        
        if (count > 10) break;  // Ğ”Ğ»Ñ Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€Ğ°
    }
    
    std::cout << "Stopping gracefully\n";
});

// Ğ Ğ°Ğ±Ğ¾Ñ‚Ğ°ĞµĞ¼ 500 Ğ¼Ñ, Ğ·Ğ°Ñ‚ĞµĞ¼ Ğ·Ğ°Ğ¿Ñ€Ğ°ÑˆĞ¸Ğ²Ğ°ĞµĞ¼ Ğ¾ÑÑ‚Ğ°Ğ½Ğ¾Ğ²ĞºÑƒ
std::this_thread::sleep_for(500ms);
worker.request_stop();  // âœ… ĞšĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ñ‹Ğ¹ Ğ·Ğ°Ğ¿Ñ€Ğ¾Ñ Ğ½Ğ° Ğ¾ÑÑ‚Ğ°Ğ½Ğ¾Ğ²ĞºÑƒ
// join() Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸ Ğ² Ğ´ĞµÑÑ‚Ñ€ÑƒĞºÑ‚Ğ¾Ñ€Ğµ worker

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Ğ¡Ñ€Ğ°Ğ²Ğ½ĞµĞ½Ğ¸Ğµ thread vs jthread
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// âŒ std::thread - Ñ‚Ñ€ĞµĞ±ÑƒĞµÑ‚ ÑĞ²Ğ½Ñ‹Ğ¹ join
std::thread old_thread([] { /* work */ });
old_thread.join();  // ĞĞ±ÑĞ·Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ğ¾!

// âœ… std::jthread - Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸Ğ¹ join
std::jthread new_thread([] { /* work */ });
// Ğ’ÑĞµ! join Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// stop_token Ğ´Ğ»Ñ ĞºĞ¾Ğ¾Ğ¿ĞµÑ€Ğ°Ñ‚Ğ¸Ğ²Ğ½Ğ¾Ğ¹ Ğ¾ÑÑ‚Ğ°Ğ½Ğ¾Ğ²ĞºĞ¸
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

std::jthread long_task([](std::stop_token st) {
    while (!st.stop_requested()) {
        // Ğ”Ğ»Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ°Ñ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°
        std::this_thread::sleep_for(100ms);
    }
    // ĞšĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ğ¾Ğµ Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ¸Ğµ
});

long_task.request_stop();  // ĞšĞ¾Ğ¾Ğ¿ĞµÑ€Ğ°Ñ‚Ğ¸Ğ²Ğ½Ğ°Ñ Ğ¾ÑÑ‚Ğ°Ğ½Ğ¾Ğ²ĞºĞ° (Ğ½Ğµ kill!)
// ĞŸĞ¾Ñ‚Ğ¾Ğº Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞ¸Ñ‚ÑÑ ĞºĞ¾Ğ³Ğ´Ğ° ÑƒĞ²Ğ¸Ğ´Ğ¸Ñ‚ stop_requested() == true

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“Œ MUTEXES Ğ˜ LOCKS - Ğ¡Ğ˜ĞĞ¥Ğ ĞĞĞ˜Ğ—ĞĞ¦Ğ˜Ğ¯ Ğ”ĞĞ¡Ğ¢Ğ£ĞŸĞ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/*
 * Ğ¢Ğ˜ĞŸĞ« ĞœĞ¬Ğ®Ğ¢Ğ•ĞšĞ¡ĞĞ’:
 * std::mutex               - Ğ‘Ğ°Ğ·Ğ¾Ğ²Ñ‹Ğ¹ Ğ¼ÑŒÑÑ‚ĞµĞºÑ
 * std::recursive_mutex     - ĞŸĞ¾Ğ²Ñ‚Ğ¾Ñ€Ğ½Ñ‹Ğ¹ lock Ğ² Ñ‚Ğ¾Ğ¼ Ğ¶Ğµ Ğ¿Ğ¾Ñ‚Ğ¾ĞºĞµ
 * std::timed_mutex         - Ğ¡ Ñ‚Ğ°Ğ¹Ğ¼Ğ°ÑƒÑ‚Ğ¾Ğ¼
 * std::shared_mutex (C++17)- Multiple readers, single writer
 * 
 * RAII LOCKS (ĞĞ‘Ğ¯Ğ—ĞĞ¢Ğ•Ğ›Ğ¬ĞĞ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ!):
 * std::lock_guard          - ĞŸÑ€Ğ¾ÑÑ‚Ğ¾Ğ¹ RAII lock
 * std::unique_lock         - Ğ“Ğ¸Ğ±ĞºĞ¸Ğ¹ RAII lock (Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ unlock/lock)
 * std::shared_lock (C++17) - Ğ”Ğ»Ñ Ñ‡Ñ‚ĞµĞ½Ğ¸Ñ Ñ shared_mutex
 * std::scoped_lock (C++17) - Ğ”Ğ»Ñ ĞĞ•Ğ¡ĞšĞĞ›Ğ¬ĞšĞ˜Ğ¥ Ğ¼ÑŒÑÑ‚ĞµĞºÑĞ¾Ğ² (Ğ±ĞµĞ· deadlock)
 */

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// std::lock_guard - Ğ¿Ñ€Ğ¾ÑÑ‚ĞµĞ¹ÑˆĞ¸Ğ¹ RAII lock
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class Counter {
private:
    mutable std::mutex mutex_;
    int value_ = 0;
    
public:
    // âœ… std::lock_guard - Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸Ğ¹ unlock
    void increment() {
        std::lock_guard<std::mutex> lock(mutex_);
        ++value_;
    }  // â† ĞĞ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸Ğ¹ unlock
    
    int get() const {
        std::lock_guard<std::mutex> lock(mutex_);
        return value_;
    }
};

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// std::unique_lock - Ğ³Ğ¸Ğ±ĞºĞ¸Ğ¹ lock (Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ unlock/lock Ğ²Ñ€ÑƒÑ‡Ğ½ÑƒÑ)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class FlexibleCounter {
    mutable std::mutex mutex_;
    int value_ = 0;
    
public:
    void add(int n) {
        std::unique_lock<std::mutex> lock(mutex_);
        value_ += n;
        
        // ĞœĞ¾Ğ¶Ğ½Ğ¾ Ñ€Ğ°Ğ·Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ñ€Ğ°Ğ½ÑŒÑˆĞµ
        lock.unlock();
        
        // Ğ”Ğ»Ğ¸Ğ½Ğ½Ğ°Ñ Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸Ñ Ğ‘Ğ•Ğ— Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²ĞºĞ¸
        std::this_thread::sleep_for(1ms);
        
        // ĞœĞ¾Ğ¶Ğ½Ğ¾ Ğ·Ğ°Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ ÑĞ½Ğ¾Ğ²Ğ°
        lock.lock();
        value_ *= 2;
    }
};

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// std::shared_mutex (C++17) - Multiple Readers, Single Writer
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/*
 * READERS-WRITER LOCK:
 * - ĞœĞ½Ğ¾Ğ¶ĞµÑÑ‚Ğ²Ğ¾ Ğ¿Ğ¾Ñ‚Ğ¾ĞºĞ¾Ğ² Ğ¼Ğ¾Ğ³ÑƒÑ‚ Ğ§Ğ˜Ğ¢ĞĞ¢Ğ¬ Ğ¾Ğ´Ğ½Ğ¾Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ½Ğ¾
 * - Ğ¢Ğ¾Ğ»ÑŒĞºĞ¾ ĞĞ”Ğ˜Ğ Ğ¿Ğ¾Ñ‚Ğ¾Ğº Ğ¼Ğ¾Ğ¶ĞµÑ‚ ĞŸĞ˜Ğ¡ĞĞ¢Ğ¬
 * 
 * Ğ˜Ğ¡ĞŸĞĞ›Ğ¬Ğ—Ğ£Ğ™Ğ¢Ğ• ĞšĞĞ“Ğ”Ğ:
 * âœ“ ĞœĞ½Ğ¾Ğ³Ğ¾ read, Ğ¼Ğ°Ğ»Ğ¾ write
 */

class SharedData {
private:
    mutable std::shared_mutex mutex_;
    std::vector<int> data_;
    
public:
    // Ğ—ĞĞŸĞ˜Ğ¡Ğ¬ - ÑĞºÑĞºĞ»ÑĞ·Ğ¸Ğ²Ğ½Ğ°Ñ Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²ĞºĞ°
    void write(int value) {
        std::unique_lock<std::shared_mutex> lock(mutex_);  // Exclusive
        data_.push_back(value);
    }
    
    // Ğ§Ğ¢Ğ•ĞĞ˜Ğ• - Ñ€Ğ°Ğ·Ğ´ĞµĞ»ÑĞµĞ¼Ğ°Ñ Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²ĞºĞ° (Ğ¼Ğ½Ğ¾Ğ³Ğ¾ Ğ¿Ğ¾Ñ‚Ğ¾ĞºĞ¾Ğ² Ğ¿Ğ°Ñ€Ğ°Ğ»Ğ»ĞµĞ»ÑŒĞ½Ğ¾)
    size_t size() const {
        std::shared_lock<std::shared_mutex> lock(mutex_);  // Shared
        return data_.size();
    }
    
    int at(size_t index) const {
        std::shared_lock<std::shared_mutex> lock(mutex_);
        return data_.at(index);
    }
};

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// std::scoped_lock (C++17) - ĞĞ•Ğ¡ĞšĞĞ›Ğ¬ĞšĞ Ğ¼ÑŒÑÑ‚ĞµĞºÑĞ¾Ğ² Ğ±ĞµĞ· deadlock
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/*
 * DEADLOCK Ğ¿Ñ€Ğ¸ 2+ Ğ¼ÑŒÑÑ‚ĞµĞºÑĞ°Ñ…:
 * Thread 1: lock(m1) â†’ lock(m2)
 * Thread 2: lock(m2) â†’ lock(m1)  â† DEADLOCK!
 * 
 * Ğ Ğ•Ğ¨Ğ•ĞĞ˜Ğ•: std::scoped_lock Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€ÑƒĞµÑ‚ Ğ²ÑĞµ Ğ°Ñ‚Ğ¾Ğ¼Ğ°Ñ€Ğ½Ğ¾
 */

class BankAccount {
    mutable std::mutex mutex_;
    int balance_ = 0;
    
public:
    void deposit(int amount) {
        std::lock_guard lock(mutex_);
        balance_ += amount;
    }
    
    // âœ… Ğ‘ĞµĞ·Ğ¾Ğ¿Ğ°ÑĞ½Ñ‹Ğ¹ transfer Ğ¼ĞµĞ¶Ğ´Ñƒ Ğ´Ğ²ÑƒĞ¼Ñ Ğ°ĞºĞºĞ°ÑƒĞ½Ñ‚Ğ°Ğ¼Ğ¸
    friend void safe_transfer(BankAccount& from, BankAccount& to, int amount) {
        // scoped_lock Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€ÑƒĞµÑ‚ ĞĞ‘Ğ Ğ¼ÑŒÑÑ‚ĞµĞºÑĞ° Ğ°Ñ‚Ğ¾Ğ¼Ğ°Ñ€Ğ½Ğ¾
        std::scoped_lock lock(from.mutex_, to.mutex_);
        from.balance_ -= amount;
        to.balance_ += amount;
    }
};

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// std::recursive_mutex - Ğ¿Ğ¾Ğ²Ñ‚Ğ¾Ñ€Ğ½Ğ°Ñ Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²ĞºĞ° Ğ² Ñ‚Ğ¾Ğ¼ Ğ¶Ğµ Ğ¿Ğ¾Ñ‚Ğ¾ĞºĞµ
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/*
 * âš ï¸ Ğ˜Ğ¡ĞŸĞĞ›Ğ¬Ğ—Ğ£Ğ™Ğ¢Ğ• Ğ Ğ•Ğ”ĞšĞ! ĞĞ±Ñ‹Ñ‡Ğ½Ğ¾ Ğ¿Ñ€Ğ¸Ğ·Ğ½Ğ°Ğº Ğ¿Ğ»Ğ¾Ñ…Ğ¾Ğ³Ğ¾ Ğ´Ğ¸Ğ·Ğ°Ğ¹Ğ½Ğ°.
 * âœ… Ğ˜Ğ½Ğ¾Ğ³Ğ´Ğ° Ğ½ÑƒĞ¶ĞµĞ½ Ğ´Ğ»Ñ Ñ€ĞµĞºÑƒÑ€ÑĞ¸Ğ²Ğ½Ñ‹Ñ… Ğ²Ñ‹Ğ·Ğ¾Ğ²Ğ¾Ğ².
 */

class RecursiveCounter {
    mutable std::recursive_mutex mutex_;
    int value_ = 0;
    
public:
    void increment() {
        std::lock_guard<std::recursive_mutex> lock(mutex_);
        ++value_;
    }
    
    void add_and_log(int n) {
        std::lock_guard<std::recursive_mutex> lock(mutex_);  // 1-Ñ Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²ĞºĞ°
        value_ += n;
        log();  // â† Ğ’Ñ‹Ğ·Ğ¾Ğ² log() ÑĞ½Ğ¾Ğ²Ğ° Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€ÑƒĞµÑ‚ mutex_
    }
    
    void log() {
        std::lock_guard<std::recursive_mutex> lock(mutex_);  // âœ… 2-Ñ Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²ĞºĞ° OK
        std::cout << "Value: " << value_ << '\n';
    }
};

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// std::timed_mutex - Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²ĞºĞ° Ñ Ñ‚Ğ°Ğ¹Ğ¼Ğ°ÑƒÑ‚Ğ¾Ğ¼
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/*
 * try_lock_for(duration) - Ğ¿Ğ¾Ğ¿Ñ‹Ñ‚ĞºĞ° Ğ½Ğ° Ğ·Ğ°Ğ´Ğ°Ğ½Ğ½Ğ¾Ğµ Ğ²Ñ€ĞµĞ¼Ñ
 * try_lock_until(time)   - Ğ´Ğ¾ Ğ¾Ğ¿Ñ€ĞµĞ´ĞµĞ»ĞµĞ½Ğ½Ğ¾Ğ³Ğ¾ Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ¸
 */

std::timed_mutex timed_mtx;

void timed_worker(int id) {
    // ĞŸĞ¾Ğ¿Ñ‹Ñ‚ĞºĞ° Ğ·Ğ°Ñ…Ğ²Ğ°Ñ‚Ğ° Ñ Ñ‚Ğ°Ğ¹Ğ¼Ğ°ÑƒÑ‚Ğ¾Ğ¼ 100 Ğ¼Ñ
    if (timed_mtx.try_lock_for(100ms)) {
        std::cout << "Thread " << id << " got lock\n";
        std::this_thread::sleep_for(50ms);
        timed_mtx.unlock();
    } else {
        std::cout << "Thread " << id << " timeout\n";
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“Œ CONDITION VARIABLES - Ğ¡Ğ˜ĞĞ¥Ğ ĞĞĞ˜Ğ—ĞĞ¦Ğ˜Ğ¯ Ğ§Ğ•Ğ Ğ•Ğ— Ğ¡ĞĞ‘Ğ«Ğ¢Ğ˜Ğ¯
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/*
 * std::condition_variable - ĞœĞ•Ğ¥ĞĞĞ˜Ğ—Ğœ ĞĞ–Ğ˜Ğ”ĞĞĞ˜Ğ¯ Ğ¡ĞĞ‘Ğ«Ğ¢Ğ˜Ğ™
 * 
 * ĞĞ¡ĞĞĞ’ĞĞ«Ğ• ĞœĞ•Ğ¢ĞĞ”Ğ«:
 * - wait(lock, predicate)     - Ğ–Ğ´ĞµÑ‚ Ğ¿Ğ¾ĞºĞ° predicate Ğ½Ğµ ÑÑ‚Ğ°Ğ½ĞµÑ‚ true
 * - wait_for(lock, duration)  - Ğ–Ğ´ĞµÑ‚ Ñ Ñ‚Ğ°Ğ¹Ğ¼Ğ°ÑƒÑ‚Ğ¾Ğ¼
 * - wait_until(lock, time)    - Ğ–Ğ´ĞµÑ‚ Ğ´Ğ¾ Ğ¾Ğ¿Ñ€ĞµĞ´ĞµĞ»ĞµĞ½Ğ½Ğ¾Ğ³Ğ¾ Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ¸
 * - notify_one()              - Ğ Ğ°Ğ·Ğ±ÑƒĞ´Ğ¸Ñ‚ÑŒ ĞĞ”Ğ˜Ğ Ğ¶Ğ´ÑƒÑ‰Ğ¸Ğ¹ Ğ¿Ğ¾Ñ‚Ğ¾Ğº
 * - notify_all()              - Ğ Ğ°Ğ·Ğ±ÑƒĞ´Ğ¸Ñ‚ÑŒ Ğ’Ğ¡Ğ• Ğ¶Ğ´ÑƒÑ‰Ğ¸Ğµ Ğ¿Ğ¾Ñ‚Ğ¾ĞºĞ¸
 * 
 * Ğ˜Ğ¡ĞŸĞĞ›Ğ¬Ğ—Ğ£Ğ™Ğ¢Ğ• ĞšĞĞ“Ğ”Ğ:
 * âœ“ ĞŸĞ¾Ñ‚Ğ¾Ğº Ğ´Ğ¾Ğ»Ğ¶ĞµĞ½ Ğ¶Ğ´Ğ°Ñ‚ÑŒ ÑĞ¾Ğ±Ñ‹Ñ‚Ğ¸Ñ Ğ¾Ñ‚ Ğ´Ñ€ÑƒĞ³Ğ¾Ğ³Ğ¾ Ğ¿Ğ¾Ñ‚Ğ¾ĞºĞ°
 * âœ“ Producer-Consumer pattern
 * âœ“ ĞÑƒĞ¶Ğ½Ğ° ĞºĞ¾Ğ¾Ñ€Ğ´Ğ¸Ğ½Ğ°Ñ†Ğ¸Ñ Ğ¼ĞµĞ¶Ğ´Ñƒ Ğ¿Ğ¾Ñ‚Ğ¾ĞºĞ°Ğ¼Ğ¸
 * 
 * âš ï¸ Ğ’ĞĞ–ĞĞ:
 * - Ğ’ÑĞµĞ³Ğ´Ğ° Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ Ñ unique_lock (Ğ½Ğµ lock_guard!)
 * - Ğ’ÑĞµĞ³Ğ´Ğ° Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ÑĞ¹Ñ‚Ğµ ÑƒÑĞ»Ğ¾Ğ²Ğ¸Ğµ Ğ² Ğ¦Ğ˜ĞšĞ›Ğ• (spurious wakeups!)
 */

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// PRODUCER-CONSUMER Ñ condition_variable
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class ThreadSafeQueue {
private:
    mutable std::mutex mutex_;
    std::condition_variable cv_;
    std::queue<int> queue_;
    bool done_ = false;
    
public:
    // PRODUCER: Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµÑ‚ ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚
    void push(int value) {
        {
            std::lock_guard<std::mutex> lock(mutex_);
            queue_.push(value);
        }  // â† unlock Ğ¿ĞµÑ€ĞµĞ´ notify!
        
        cv_.notify_one();  // Ğ Ğ°Ğ·Ğ±ÑƒĞ´Ğ¸Ñ‚ÑŒ ĞĞ”Ğ˜Ğ Ğ¶Ğ´ÑƒÑ‰Ğ¸Ğ¹ Ğ¿Ğ¾Ñ‚Ğ¾Ğº
    }
    
    // CONSUMER: Ğ¶Ğ´ĞµÑ‚ Ğ¸ Ğ·Ğ°Ğ±Ğ¸Ñ€Ğ°ĞµÑ‚ ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚
    bool pop(int& value) {
        std::unique_lock<std::mutex> lock(mutex_);  // unique_lock Ğ´Ğ»Ñ wait!
        
        // âš ï¸ Ğ’ĞĞ–ĞĞ: wait Ñ Ğ¿Ñ€ĞµĞ´Ğ¸ĞºĞ°Ñ‚Ğ¾Ğ¼ (Ğ·Ğ°Ñ‰Ğ¸Ñ‚Ğ° Ğ¾Ñ‚ spurious wakeups)
        cv_.wait(lock, [this] { 
            return !queue_.empty() || done_;  // Ğ–Ğ´ĞµĞ¼ Ğ¿Ğ¾ĞºĞ° Ğ½Ğµ Ğ¿Ğ¾ÑĞ²Ğ¸Ñ‚ÑÑ ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚
        });
        
        if (queue_.empty()) {
            return false;  // ĞÑ‡ĞµÑ€ĞµĞ´ÑŒ Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ°
        }
        
        value = queue_.front();
        queue_.pop();
        return true;
    }
    
    // CONSUMER: Ğ¿Ğ¾Ğ¿Ñ‹Ñ‚ĞºĞ° Ñ Ñ‚Ğ°Ğ¹Ğ¼Ğ°ÑƒÑ‚Ğ¾Ğ¼
    bool try_pop(int& value, std::chrono::milliseconds timeout) {
        std::unique_lock<std::mutex> lock(mutex_);
        
        // wait_for Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµÑ‚ false Ğ¿Ñ€Ğ¸ Ñ‚Ğ°Ğ¹Ğ¼Ğ°ÑƒÑ‚Ğµ
        if (!cv_.wait_for(lock, timeout, [this] { 
            return !queue_.empty() || done_; 
        })) {
            return false;  // Ğ¢Ğ°Ğ¹Ğ¼Ğ°ÑƒÑ‚ Ğ¸ÑÑ‚ĞµĞº
        }
        
        if (queue_.empty()) {
            return false;  // done_ == true
        }
        
        value = queue_.front();
        queue_.pop();
        return true;
    }
    
    // Ğ¡Ğ¸Ğ³Ğ½Ğ°Ğ» Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ¸Ñ
    void finish() {
        {
            std::lock_guard<std::mutex> lock(mutex_);
            done_ = true;
        }
        
        cv_.notify_all();  // Ğ Ğ°Ğ·Ğ±ÑƒĞ´Ğ¸Ñ‚ÑŒ Ğ’Ğ¡Ğ• Ğ¶Ğ´ÑƒÑ‰Ğ¸Ğµ Ğ¿Ğ¾Ñ‚Ğ¾ĞºĞ¸
    }
};

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ ThreadSafeQueue
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

ThreadSafeQueue task_queue;

// Producer thread
std::jthread producer([&] {
    for (int i = 0; i < 10; ++i) {
        task_queue.push(i);
        std::cout << "Produced: " << i << '\n';
        std::this_thread::sleep_for(50ms);
    }
    task_queue.finish();  // Ğ¡Ğ¸Ğ³Ğ½Ğ°Ğ» Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ¸Ñ
});

// Consumer thread
std::jthread consumer([&] {
    int value;
    while (task_queue.pop(value)) {  // Ğ‘Ğ»Ğ¾ĞºĞ¸Ñ€ÑƒĞµÑ‚ÑÑ Ğ¿Ğ¾ĞºĞ° Ğ½ĞµÑ‚ ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚Ğ¾Ğ²
        std::cout << "Consumed: " << value << '\n';
    }
    std::cout << "Consumer finished\n";
});

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// âš ï¸ SPURIOUS WAKEUPS - Ğ›ĞĞ–ĞĞ«Ğ• ĞŸĞ ĞĞ‘Ğ£Ğ–Ğ”Ğ•ĞĞ˜Ğ¯
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/*
 * âŒ ĞŸĞ›ĞĞ¥Ğ: wait Ğ±ĞµĞ· Ğ¿Ñ€ĞµĞ´Ğ¸ĞºĞ°Ñ‚Ğ° (ÑƒÑĞ·Ğ²Ğ¸Ğ¼ Ğº spurious wakeups)
 */
void bad_wait_example() {
    std::mutex mtx;
    std::condition_variable cv;
    bool ready = false;
    
    std::unique_lock lock(mtx);
    cv.wait(lock);  // âŒ ĞœĞ¾Ğ¶ĞµÑ‚ Ğ¿Ñ€Ğ¾ÑĞ½ÑƒÑ‚ÑŒÑÑ Ğ‘Ğ•Ğ— notify!
    // ĞĞµÑ‚ Ğ³Ğ°Ñ€Ğ°Ğ½Ñ‚Ğ¸Ğ¸ Ñ‡Ñ‚Ğ¾ ready == true
}

/*
 * âœ… Ğ¥ĞĞ ĞĞ¨Ğ: wait Ñ Ğ¿Ñ€ĞµĞ´Ğ¸ĞºĞ°Ñ‚Ğ¾Ğ¼ (Ğ·Ğ°Ñ‰Ğ¸Ñ‚Ğ° Ğ¾Ñ‚ spurious wakeups)
 */
void good_wait_example() {
    std::mutex mtx;
    std::condition_variable cv;
    bool ready = false;
    
    std::unique_lock lock(mtx);
    cv.wait(lock, [&] { return ready; });  // âœ… ĞŸÑ€Ğ¾ÑĞ½ĞµÑ‚ÑÑ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ ĞºĞ¾Ğ³Ğ´Ğ° ready == true
    // Ğ“Ğ°Ñ€Ğ°Ğ½Ñ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ğ¾ ready == true
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“Œ SEMAPHORES (C++20) - ĞĞ“Ğ ĞĞĞ˜Ğ§Ğ•ĞĞ˜Ğ• Ğ”ĞĞ¡Ğ¢Ğ£ĞŸĞ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/*
 * SEMAPHORE - Ğ¡Ğ§Ğ•Ğ¢Ğ§Ğ˜Ğš Ğ¡ Ğ‘Ğ›ĞĞšĞ˜Ğ ĞĞ’ĞšĞĞ™
 * 
 * std::counting_semaphore<N> - ĞœĞ°ĞºÑĞ¸Ğ¼ÑƒĞ¼ N Ğ¾Ğ´Ğ½Ğ¾Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ½Ñ‹Ñ… Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ¾Ğ²
 * std::binary_semaphore      - Ğ‘Ğ¸Ğ½Ğ°Ñ€Ğ½Ñ‹Ğ¹ (0 Ğ¸Ğ»Ğ¸ 1), ĞºĞ°Ğº mutex
 * 
 * ĞœĞ•Ğ¢ĞĞ”Ğ«:
 * - acquire()     - Ğ£Ğ¼ĞµĞ½ÑŒÑˆĞ¸Ñ‚ÑŒ ÑÑ‡ĞµÑ‚Ñ‡Ğ¸Ğº (Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€ÑƒĞµÑ‚ÑÑ ĞµÑĞ»Ğ¸ 0)
 * - release(n=1)  - Ğ£Ğ²ĞµĞ»Ğ¸Ñ‡Ğ¸Ñ‚ÑŒ ÑÑ‡ĞµÑ‚Ñ‡Ğ¸Ğº Ğ½Ğ° n
 * - try_acquire() - ĞŸĞ¾Ğ¿Ñ‹Ñ‚ĞºĞ° Ğ±ĞµĞ· Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²ĞºĞ¸
 * 
 * Ğ˜Ğ¡ĞŸĞĞ›Ğ¬Ğ—Ğ£Ğ™Ğ¢Ğ• ĞšĞĞ“Ğ”Ğ:
 * âœ“ ĞĞ³Ñ€Ğ°Ğ½Ğ¸Ñ‡ĞµĞ½Ğ¸Ğµ Ñ‡Ğ¸ÑĞ»Ğ° Ğ¾Ğ´Ğ½Ğ¾Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ½Ñ‹Ñ… Ğ¿Ğ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğ¹
 * âœ“ Connection pool
 * âœ“ Rate limiting
 */

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// counting_semaphore - Ğ¾Ğ³Ñ€Ğ°Ğ½Ğ¸Ñ‡ĞµĞ½Ğ¸Ğµ Ñ‡Ğ¸ÑĞ»Ğ° Ğ¿Ğ¾Ñ‚Ğ¾ĞºĞ¾Ğ²
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// ĞŸÑ€Ğ¸Ğ¼ĞµÑ€: Ğ¼Ğ°ĞºÑĞ¸Ğ¼ÑƒĞ¼ 3 Ğ¿Ğ¾Ñ‚Ğ¾ĞºĞ° Ğ¾Ğ´Ğ½Ğ¾Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ½Ğ¾ (connection pool)
std::counting_semaphore<3> connection_pool(3);  // ĞĞ°Ñ‡Ğ°Ğ»ÑŒĞ½Ğ¾Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ = 3

auto database_worker = [&](int id) {
    connection_pool.acquire();  // â³ Ğ–Ğ´ĞµĞ¼ ÑĞ²Ğ¾Ğ±Ğ¾Ğ´Ğ½Ğ¾Ğ³Ğ¾ ÑĞ»Ğ¾Ñ‚Ğ° (Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€ÑƒĞµÑ‚ÑÑ ĞµÑĞ»Ğ¸ 0)
    
    std::cout << "Thread " << id << " got connection\n";
    std::this_thread::sleep_for(100ms);  // Ğ Ğ°Ğ±Ğ¾Ñ‚Ğ° Ñ Ğ‘Ğ”
    std::cout << "Thread " << id << " releasing connection\n";
    
    connection_pool.release();  // âœ… ĞÑĞ²Ğ¾Ğ±Ğ¾Ğ¶Ğ´Ğ°ĞµĞ¼ ÑĞ»Ğ¾Ñ‚ (ÑƒĞ²ĞµĞ»Ğ¸Ñ‡Ğ¸Ğ²Ğ°ĞµĞ¼ ÑÑ‡ĞµÑ‚Ñ‡Ğ¸Ğº)
};

// Ğ—Ğ°Ğ¿ÑƒÑĞºĞ°ĞµĞ¼ 10 Ğ¿Ğ¾Ñ‚Ğ¾ĞºĞ¾Ğ², Ğ½Ğ¾ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°Ñ‚ÑŒ Ğ±ÑƒĞ´ÑƒÑ‚ Ğ¼Ğ°ĞºÑĞ¸Ğ¼ÑƒĞ¼ 3 Ğ¾Ğ´Ğ½Ğ¾Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ½Ğ¾
std::vector<std::jthread> workers;
for (int i = 0; i < 10; ++i) {
    workers.emplace_back(database_worker, i);
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// binary_semaphore - ĞºĞ°Ğº Ğ¼ÑŒÑÑ‚ĞµĞºÑ (0 Ğ¸Ğ»Ğ¸ 1)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

std::binary_semaphore signal(0);  // ĞĞ°Ñ‡Ğ°Ğ»ÑŒĞ½Ğ¾Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ = 0 (Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚)

// ĞŸĞ¾Ñ‚Ğ¾Ğº-Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ¸Ñ‚ĞµĞ»ÑŒ
std::jthread signaler([&] {
    std::this_thread::sleep_for(200ms);
    std::cout << "Sending signal\n";
    signal.release();  // ĞÑ‚ĞºÑ€Ñ‹Ñ‚ÑŒ (0 â†’ 1)
});

// ĞŸĞ¾Ñ‚Ğ¾Ğº-Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ°Ñ‚ĞµĞ»ÑŒ
std::jthread waiter([&] {
    std::cout << "Waiting for signal...\n";
    signal.acquire();  // â³ Ğ‘Ğ»Ğ¾ĞºĞ¸Ñ€ÑƒĞµÑ‚ÑÑ Ğ¿Ğ¾ĞºĞ° ÑÑ‡ĞµÑ‚Ñ‡Ğ¸Ğº 0
    std::cout << "Signal received!\n";
});

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// try_acquire() - Ğ¿Ğ¾Ğ¿Ñ‹Ñ‚ĞºĞ° Ğ±ĞµĞ· Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²ĞºĞ¸
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

std::counting_semaphore<1> resource(1);

if (resource.try_acquire()) {
    // âœ… Ğ£ÑĞ¿ĞµÑˆĞ½Ğ¾ Ğ·Ğ°Ñ…Ğ²Ğ°Ñ‚Ğ¸Ğ»Ğ¸
    std::cout << "Got resource\n";
    // Ğ Ğ°Ğ±Ğ¾Ñ‚Ğ°...
    resource.release();
} else {
    // âŒ Ğ ĞµÑÑƒÑ€Ñ Ğ·Ğ°Ğ½ÑÑ‚
    std::cout << "Resource busy\n";
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“Œ LATCHES Ğ˜ BARRIERS (C++20) - Ğ¡Ğ˜ĞĞ¥Ğ ĞĞĞ˜Ğ—ĞĞ¦Ğ˜Ğ¯ Ğ“Ğ Ğ£ĞŸĞŸ ĞŸĞĞ¢ĞĞšĞĞ’
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/*
 * std::latch (C++20)   - ĞĞ”ĞĞĞ ĞĞ—ĞĞ’Ğ«Ğ™ Ğ±Ğ°Ñ€ÑŒĞµÑ€ (Ğ¾Ğ´Ğ½Ğ¾ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ)
 * std::barrier (C++20) - ĞœĞĞĞ“ĞĞ ĞĞ—ĞĞ’Ğ«Ğ™ Ğ±Ğ°Ñ€ÑŒĞµÑ€ (Ñ†Ğ¸ĞºĞ»Ñ‹/Ñ„Ğ°Ğ·Ñ‹)
 * 
 * LATCH - Ğ¶Ğ´ĞµĞ¼ N ÑĞ¾Ğ±Ñ‹Ñ‚Ğ¸Ğ¹, Ğ·Ğ°Ñ‚ĞµĞ¼ Ğ²ÑĞµ Ğ¿Ñ€Ğ¾Ğ´Ğ¾Ğ»Ğ¶Ğ°ÑÑ‚:
 * - count_down()        - Ğ£Ğ¼ĞµĞ½ÑŒÑˆĞ¸Ñ‚ÑŒ ÑÑ‡ĞµÑ‚Ñ‡Ğ¸Ğº
 * - wait()              - Ğ–Ğ´Ğ°Ñ‚ÑŒ Ğ¿Ğ¾ĞºĞ° ÑÑ‡ĞµÑ‚Ñ‡Ğ¸Ğº Ğ½Ğµ ÑÑ‚Ğ°Ğ½ĞµÑ‚ 0
 * - arrive_and_wait()   - count_down() + wait()
 * 
 * BARRIER - Ñ†Ğ¸ĞºĞ»Ğ¸Ñ‡ĞµÑĞºĞ°Ñ ÑĞ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ N Ğ¿Ğ¾Ñ‚Ğ¾ĞºĞ¾Ğ²:
 * - arrive_and_wait()   - Ğ–Ğ´Ğ°Ñ‚ÑŒ Ğ²ÑĞµÑ… N Ğ¿Ğ¾Ñ‚Ğ¾ĞºĞ¾Ğ²
 * - arrive_and_drop()   - ĞŸĞ¾ĞºĞ¸Ğ½ÑƒÑ‚ÑŒ Ğ±Ğ°Ñ€ÑŒĞµÑ€ Ğ½Ğ°ÑĞ¾Ğ²ÑĞµĞ¼
 */

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// std::latch - ĞĞ”ĞĞĞ ĞĞ—ĞĞ’Ğ«Ğ™ Ğ±Ğ°Ñ€ÑŒĞµÑ€ (Ğ¶Ğ´ĞµĞ¼ N ÑĞ¾Ğ±Ñ‹Ñ‚Ğ¸Ğ¹)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/*
 * Ğ¡Ğ¦Ğ•ĞĞĞ Ğ˜Ğ™: Main thread Ğ¶Ğ´ĞµÑ‚ Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ¸Ñ 3 worker threads
 */

std::latch workers_done(3);  // Ğ–Ğ´ĞµĞ¼ 3 Ğ¿Ğ¾Ñ‚Ğ¾ĞºĞ°

auto worker_task = [&](int id) {
    std::cout << "Worker " << id << " starting\n";
    std::this_thread::sleep_for(100ms * id);  // Ğ Ğ°Ğ±Ğ¾Ñ‚Ğ°
    std::cout << "Worker " << id << " done\n";
    
    workers_done.count_down();  // âœ… Ğ£Ğ¼ĞµĞ½ÑŒÑˆĞ¸Ñ‚ÑŒ ÑÑ‡ĞµÑ‚Ñ‡Ğ¸Ğº (3 â†’ 2 â†’ 1 â†’ 0)
};

std::jthread w1(worker_task, 1);
std::jthread w2(worker_task, 2);
std::jthread w3(worker_task, 3);

std::cout << "Main: waiting for workers...\n";
workers_done.wait();  // â³ Ğ‘Ğ»Ğ¾ĞºĞ¸Ñ€ÑƒĞµÑ‚ÑÑ Ğ¿Ğ¾ĞºĞ° ÑÑ‡ĞµÑ‚Ñ‡Ğ¸Ğº Ğ½Ğµ ÑÑ‚Ğ°Ğ½ĞµÑ‚ 0
std::cout << "Main: all workers completed!\n";

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// std::latch Ñ arrive_and_wait() - ĞºĞ¾Ğ¼Ğ±Ğ¾ count_down + wait
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

std::latch start_signal(3);  // Ğ’ÑĞµ Ğ¶Ğ´ÑƒÑ‚ Ğ´Ñ€ÑƒĞ³ Ğ´Ñ€ÑƒĞ³Ğ° Ğ¿ĞµÑ€ĞµĞ´ ÑÑ‚Ğ°Ñ€Ñ‚Ğ¾Ğ¼

auto racer = [&](int id) {
    std::cout << "Racer " << id << " ready\n";
    start_signal.arrive_and_wait();  // count_down() + wait()
    // âœ… Ğ’ÑĞµ 3 Ğ¿Ğ¾Ñ‚Ğ¾ĞºĞ° ÑÑ‚Ğ°Ñ€Ñ‚ÑƒÑÑ‚ ĞĞ”ĞĞĞ’Ğ Ğ•ĞœĞ•ĞĞĞ Ğ¿Ğ¾ÑĞ»Ğµ ÑÑ‚Ğ¾Ğ¹ Ñ‚Ğ¾Ñ‡ĞºĞ¸
    std::cout << "Racer " << id << " GO!\n";
};

std::jthread r1(racer, 1);
std::jthread r2(racer, 2);
std::jthread r3(racer, 3);

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// std::barrier - ĞœĞĞĞ“ĞĞ ĞĞ—ĞĞ’Ğ«Ğ™ Ğ±Ğ°Ñ€ÑŒĞµÑ€ (Ğ´Ğ»Ñ Ñ„Ğ°Ğ·/Ñ†Ğ¸ĞºĞ»Ğ¾Ğ²)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/*
 * Ğ¡Ğ¦Ğ•ĞĞĞ Ğ˜Ğ™: ĞŸĞ°Ñ€Ğ°Ğ»Ğ»ĞµĞ»ÑŒĞ½Ñ‹Ğµ Ğ²Ñ‹Ñ‡Ğ¸ÑĞ»ĞµĞ½Ğ¸Ñ Ğ² Ğ½ĞµÑĞºĞ¾Ğ»ÑŒĞºĞ¾ Ñ„Ğ°Ğ·,
 * Ğ³Ğ´Ğµ ĞºĞ°Ğ¶Ğ´Ğ°Ñ Ñ„Ğ°Ğ·Ğ° Ñ‚Ñ€ĞµĞ±ÑƒĞµÑ‚ ÑĞ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¸ Ğ²ÑĞµÑ… Ğ¿Ğ¾Ñ‚Ğ¾ĞºĞ¾Ğ².
 */

// Callback Ğ²Ñ‹Ğ·Ñ‹Ğ²Ğ°ĞµÑ‚ÑÑ ĞºĞ¾Ğ³Ğ´Ğ° Ğ²ÑĞµ Ğ¿Ğ¾Ñ‚Ğ¾ĞºĞ¸ Ğ´Ğ¾ÑÑ‚Ğ¸Ğ³Ğ»Ğ¸ Ğ±Ğ°Ñ€ÑŒĞµÑ€Ğ°
auto on_phase_completion = []() noexcept {
    std::cout << "\n=== Phase completed ===\n";
};

std::barrier sync_point(3, on_phase_completion);  // 3 Ğ¿Ğ¾Ñ‚Ğ¾ĞºĞ°, callback

auto phased_worker = [&](int id) {
    for (int phase = 0; phase < 3; ++phase) {
        std::cout << "Worker " << id << " phase " << phase << "\n";
        std::this_thread::sleep_for(50ms * id);  // Ğ Ğ°Ğ±Ğ¾Ñ‚Ğ° Ñ„Ğ°Ğ·Ñ‹
        
        sync_point.arrive_and_wait();  // â³ Ğ–Ğ´ĞµĞ¼ Ğ¿Ğ¾ĞºĞ° Ğ²ÑĞµ 3 Ğ½Ğµ Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞ°Ñ‚ Ñ„Ğ°Ğ·Ñƒ
        // âœ… ĞŸĞ¾ÑĞ»Ğµ ÑÑ‚Ğ¾Ğ¹ Ñ‚Ğ¾Ñ‡ĞºĞ¸ Ğ²ÑĞµ ÑĞ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ğ¸Ğ·Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ñ‹, Ğ½Ğ°Ñ‡Ğ¸Ğ½Ğ°ĞµÑ‚ÑÑ ÑĞ»ĞµĞ´ÑƒÑÑ‰Ğ°Ñ Ñ„Ğ°Ğ·Ğ°
    }
};

std::jthread pw1(phased_worker, 1);
std::jthread pw2(phased_worker, 2);
std::jthread pw3(phased_worker, 3);

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Ğ¡Ñ€Ğ°Ğ²Ğ½ĞµĞ½Ğ¸Ğµ latch vs barrier
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/*
 * LATCH:
 * âœ“ ĞĞ´Ğ½Ğ¾Ñ€Ğ°Ğ·Ğ¾Ğ²Ñ‹Ğ¹ (Ğ¾Ğ´Ğ½Ğ¾ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ)
 * âœ“ ĞÑĞ¸Ğ¼Ğ¼ĞµÑ‚Ñ€Ğ¸Ñ‡Ğ½Ñ‹Ğ¹ (Ñ€Ğ°Ğ·Ğ½Ñ‹Ğµ Ğ¿Ğ¾Ñ‚Ğ¾ĞºĞ¸ count_down/wait)
 * âœ“ Ğ”Ğ»Ñ "Ğ¶Ğ´Ğ°Ñ‚ÑŒ Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ¸Ñ N Ğ·Ğ°Ğ´Ğ°Ñ‡"
 * 
 * BARRIER:
 * âœ“ ĞœĞ½Ğ¾Ğ³Ğ¾Ñ€Ğ°Ğ·Ğ¾Ğ²Ñ‹Ğ¹ (Ñ†Ğ¸ĞºĞ»Ñ‹/Ñ„Ğ°Ğ·Ñ‹)
 * âœ“ Ğ¡Ğ¸Ğ¼Ğ¼ĞµÑ‚Ñ€Ğ¸Ñ‡Ğ½Ñ‹Ğ¹ (Ğ²ÑĞµ Ğ¿Ğ¾Ñ‚Ğ¾ĞºĞ¸ arrive_and_wait)
 * âœ“ Ğ”Ğ»Ñ "ÑĞ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ğ¸Ğ·Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ N Ğ¿Ğ¾Ñ‚Ğ¾ĞºĞ¾Ğ² Ğ² ĞºĞ°Ğ¶Ğ´Ğ¾Ğ¹ Ğ¸Ñ‚ĞµÑ€Ğ°Ñ†Ğ¸Ğ¸"
 * âœ“ ĞĞ¿Ñ†Ğ¸Ğ¾Ğ½Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹ callback Ğ¿Ğ¾ÑĞ»Ğµ ĞºĞ°Ğ¶Ğ´Ğ¾Ğ¹ Ñ„Ğ°Ğ·Ñ‹
 */

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“Œ ATOMIC OPERATIONS - Ğ‘Ğ•Ğ— Ğ‘Ğ›ĞĞšĞ˜Ğ ĞĞ’ĞĞš
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/*
 * std::atomic<T> - LOCK-FREE Ğ¡Ğ˜ĞĞ¥Ğ ĞĞĞ˜Ğ—ĞĞ¦Ğ˜Ğ¯
 * 
 * ĞŸĞ Ğ•Ğ˜ĞœĞ£Ğ©Ğ•Ğ¡Ğ¢Ğ’Ğ vs mutex:
 * âœ“ Ğ‘Ñ‹ÑÑ‚Ñ€ĞµĞµ (lock-free CPU Ğ¸Ğ½ÑÑ‚Ñ€ÑƒĞºÑ†Ğ¸Ğ¸)
 * âœ“ ĞĞµÑ‚ deadlock
 * âœ“ ĞŸÑ€Ğ¾ÑÑ‚Ñ‹Ğµ ÑÑ‡ĞµÑ‚Ñ‡Ğ¸ĞºĞ¸/Ñ„Ğ»Ğ°Ğ³Ğ¸
 * 
 * ĞĞŸĞ•Ğ ĞĞ¦Ğ˜Ğ˜:
 * - load/store - Ñ‡Ñ‚ĞµĞ½Ğ¸Ğµ/Ğ·Ğ°Ğ¿Ğ¸ÑÑŒ
 * - fetch_add/sub - +/- Ğ¸ Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‚ ÑÑ‚Ğ°Ñ€Ğ¾Ğ³Ğ¾
 * - exchange - Ğ¾Ğ±Ğ¼ĞµĞ½ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ñ
 * - compare_exchange - CAS (Compare-And-Swap)
 */

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Ğ‘Ğ°Ğ·Ğ¾Ğ²Ñ‹Ğµ Ğ°Ñ‚Ğ¾Ğ¼Ğ°Ñ€Ğ½Ñ‹Ğµ Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸Ğ¸
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

std::atomic<int> atomic_counter{0};

atomic_counter++;                        // ĞÑ‚Ğ¾Ğ¼Ğ°Ñ€Ğ½Ñ‹Ğ¹ ++
atomic_counter += 5;                     // ĞÑ‚Ğ¾Ğ¼Ğ°Ñ€Ğ½Ğ¾Ğµ +=
int old_val = atomic_counter.fetch_add(10);  // +10, Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‚ ÑÑ‚Ğ°Ñ€Ğ¾Ğ³Ğ¾
int swapped = atomic_counter.exchange(100);  // ĞĞ±Ğ¼ĞµĞ½ â†’ 100

// load/store
int current = atomic_counter.load();     // Ğ§Ñ‚ĞµĞ½Ğ¸Ğµ
atomic_counter.store(200);               // Ğ—Ğ°Ğ¿Ğ¸ÑÑŒ

// is_lock_free - CPU Ğ¸Ğ½ÑÑ‚Ñ€ÑƒĞºÑ†Ğ¸Ğ¸ Ğ±ĞµĞ· Ğ¼ÑŒÑÑ‚ĞµĞºÑĞ°
std::cout << "Lock-free: " << std::atomic<int>::is_always_lock_free << '\n';

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Compare-Exchange (CAS) - Ğ°Ñ‚Ğ¾Ğ¼Ğ°Ñ€Ğ½Ğ¾Ğµ ÑÑ€Ğ°Ğ²Ğ½ĞµĞ½Ğ¸Ğµ Ğ¸ Ğ¾Ğ±Ğ¼ĞµĞ½
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

std::atomic<int> cas_val{100};
int expected = 100;
int desired = 200;

// strong - Ğ½Ğµ Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ğ»Ğ¾Ğ¶Ğ½Ğ¾ Ğ¿Ñ€Ğ¾Ğ²Ğ°Ğ»Ğ¸Ñ‚ÑŒÑÑ
bool ok = cas_val.compare_exchange_strong(expected, desired);
// Ğ•ÑĞ»Ğ¸ cas_val == 100 â†’ cas_val = 200, return true
// Ğ˜Ğ½Ğ°Ñ‡Ğµ â†’ expected = cas_val, return false

// weak - Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ğ»Ğ¾Ğ¶Ğ½Ğ¾ Ğ¿Ñ€Ğ¾Ğ²Ğ°Ğ»Ğ¸Ñ‚ÑŒÑÑ (Ğ´Ğ»Ñ Ñ†Ğ¸ĞºĞ»Ğ¾Ğ²)
expected = 200;
while (!cas_val.compare_exchange_weak(expected, 300)) {
    // ĞŸĞ¾Ğ²Ñ‚Ğ¾Ñ€ Ğ¿Ñ€Ğ¸ spurious failure
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Memory Ordering - Ğ¼Ğ¾Ğ´ĞµĞ»ÑŒ Ğ¿Ğ°Ğ¼ÑÑ‚Ğ¸
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/*
 * Ğ¢Ğ˜ĞŸĞ«:
 * - memory_order_relaxed - Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ°Ñ‚Ğ¾Ğ¼Ğ°Ñ€Ğ½Ğ¾ÑÑ‚ÑŒ
 * - memory_order_acquire - Ğ´Ğ»Ñ Ñ‡Ñ‚ĞµĞ½Ğ¸Ñ (Ğ²Ğ¸Ğ´Ğ¸Ñ‚ release)
 * - memory_order_release - Ğ´Ğ»Ñ Ğ·Ğ°Ğ¿Ğ¸ÑĞ¸ (Ğ²ÑĞµ Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸Ğ¸ Ğ´Ğ¾ Ğ²Ğ¸Ğ´Ğ½Ñ‹)
 * - memory_order_seq_cst - sequential (default, Ğ¼ĞµĞ´Ğ»ĞµĞ½Ğ½ĞµĞµ)
 * 
 * ĞŸĞĞ¢Ğ¢Ğ•Ğ Ğ: Producer (release) â†’ Consumer (acquire)
 */

std::atomic<int> shared_data{0};
std::atomic<bool> data_ready{false};

// Producer
auto producer = [&] {
    shared_data.store(42, std::memory_order_relaxed);
    data_ready.store(true, std::memory_order_release);  // Ğ’ÑĞµ Ğ²Ñ‹ÑˆĞµ Ğ²Ğ¸Ğ´Ğ½Ğ¾
};

// Consumer  
auto consumer = [&] {
    while (!data_ready.load(std::memory_order_acquire)) {  // Ğ’Ğ¸Ğ´Ğ¸Ñ‚ Ğ²ÑĞµ Ğ´Ğ¾ release
        std::this_thread::yield();
    }
    int val = shared_data.load(std::memory_order_relaxed);  // Ğ“Ğ°Ñ€Ğ°Ğ½Ñ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ğ¾ 42
    std::cout << "Data: " << val << '\n';
};

std::jthread prod(producer);
std::jthread cons(consumer);

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Atomic wait/notify (C++20) - Ğ»ĞµĞ³ĞºĞ¾Ğ²ĞµÑ vs condition_variable
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

std::atomic<int> signal{0};

std::jthread waiter([&] {
    std::cout << "Waiting...\n";
    signal.wait(0);  // Ğ‘Ğ»Ğ¾ĞºĞ¸Ñ€ÑƒĞµÑ‚ÑÑ Ğ¿Ğ¾ĞºĞ° != 0
    std::cout << "Got: " << signal.load() << '\n';
});

std::this_thread::sleep_for(100ms);
signal.store(42);
signal.notify_one();  // Ğ Ğ°Ğ·Ğ±ÑƒĞ´Ğ¸Ñ‚ÑŒ

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Atomic shared_ptr (C++20)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

std::atomic<std::shared_ptr<int>> atomic_ptr;

atomic_ptr.store(std::make_shared<int>(42));
auto current_ptr = atomic_ptr.load();

// CAS Ğ´Ğ»Ñ Ğ·Ğ°Ğ¼ĞµĞ½Ñ‹
auto expected_ptr = current_ptr;
auto new_ptr = std::make_shared<int>(100);
atomic_ptr.compare_exchange_strong(expected_ptr, new_ptr);



// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“Œ FUTURES & PROMISES - ĞĞ¡Ğ˜ĞĞ¥Ğ ĞĞĞĞ«Ğ• Ğ Ğ•Ğ—Ğ£Ğ›Ğ¬Ğ¢ĞĞ¢Ğ«
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/*
 * std::future<T>        - Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚ Ğ¸Ğ· Ğ´Ñ€ÑƒĞ³Ğ¾Ğ³Ğ¾ Ğ¿Ğ¾Ñ‚Ğ¾ĞºĞ°
 * std::promise<T>       - ÑƒÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚ Ğ´Ğ»Ñ future
 * std::async            - Ğ¿Ñ€Ğ¾ÑÑ‚ĞµĞ¹ÑˆĞ¸Ğ¹ ÑĞ¿Ğ¾ÑĞ¾Ğ± async Ğ²Ñ‹Ñ‡Ğ¸ÑĞ»ĞµĞ½Ğ¸Ğ¹
 * std::packaged_task<>  - Ğ¾Ğ±Ğ¾Ñ€Ğ°Ñ‡Ğ¸Ğ²Ğ°ĞµÑ‚ callable + future
 * std::shared_future<T> - Ğ¼Ğ½Ğ¾Ğ¶ĞµÑÑ‚Ğ²ĞµĞ½Ğ½Ñ‹Ğµ get()
 */

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// std::async - Ğ¿Ñ€Ğ¾ÑÑ‚ĞµĞ¹ÑˆĞ¸Ğ¹ ÑĞ¿Ğ¾ÑĞ¾Ğ± Ğ°ÑĞ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ğ½Ñ‹Ñ… Ğ²Ñ‹Ñ‡Ğ¸ÑĞ»ĞµĞ½Ğ¸Ğ¹
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

auto future_result = std::async(std::launch::async, [] {
    std::this_thread::sleep_for(100ms);  // Ğ Ğ°Ğ±Ğ¾Ñ‚Ğ°
    return 42;
});

std::cout << "Waiting...\n";
int result = future_result.get();  // â³ Ğ‘Ğ»Ğ¾ĞºĞ¸Ñ€ÑƒĞµÑ‚ÑÑ Ğ´Ğ¾ Ğ³Ğ¾Ñ‚Ğ¾Ğ²Ğ½Ğ¾ÑÑ‚Ğ¸
std::cout << "Result: " << result << '\n';

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Launch policies
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/*
 * std::launch::async    - Ğ³Ğ°Ñ€Ğ°Ğ½Ñ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ğ¾ Ğ½Ğ¾Ğ²Ñ‹Ğ¹ Ğ¿Ğ¾Ñ‚Ğ¾Ğº
 * std::launch::deferred - Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ÑÑ Ğ¿Ñ€Ğ¸ get() Ğ² Ğ²Ñ‹Ğ·Ñ‹Ğ²Ğ°ÑÑ‰ĞµĞ¼ Ğ¿Ğ¾Ñ‚Ğ¾ĞºĞµ
 * async | deferred      - Ğ½Ğ° ÑƒÑĞ¼Ğ¾Ñ‚Ñ€ĞµĞ½Ğ¸Ğµ Ñ€ĞµĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¸ (default)
 */

auto async_task = std::async(std::launch::async, [] { return 100; });      // ĞĞ¾Ğ²Ñ‹Ğ¹ Ğ¿Ğ¾Ñ‚Ğ¾Ğº
auto deferred_task = std::async(std::launch::deferred, [] { return 200; }); // ĞŸÑ€Ğ¸ get()

deferred_task.get();  // â† Ğ’Ñ‹Ğ¿Ğ¾Ğ»Ğ½ÑĞµÑ‚ÑÑ Ğ—Ğ”Ğ•Ğ¡Ğ¬

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// std::promise & std::future - Ñ€ÑƒÑ‡Ğ½Ğ¾Ğµ ÑƒĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

std::promise<int> prom;
std::future<int> fut = prom.get_future();

std::jthread worker([&] {
    try {
        std::this_thread::sleep_for(100ms);
        int result = 42;
        prom.set_value(result);  // âœ… Ğ£ÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚
    } catch (...) {
        prom.set_exception(std::current_exception());  // âŒ ĞÑˆĞ¸Ğ±ĞºĞ°
    }
});

try {
    int value = fut.get();  // ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚ Ğ¸Ğ»Ğ¸ exception
    std::cout << "Got: " << value << '\n';
} catch (const std::exception& e) {
    std::cout << "Exception: " << e.what() << '\n';
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// std::packaged_task - Ğ¾Ğ±Ğ¾Ñ€Ğ°Ñ‡Ğ¸Ğ²Ğ°ĞµÑ‚ callable + future
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

std::packaged_task<int(int, int)> task([](int a, int b) {
    return a + b;
});

std::future<int> task_future = task.get_future();

// Ğ’Ñ‹Ğ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ÑŒ Ğ² Ğ´Ñ€ÑƒĞ³Ğ¾Ğ¼ Ğ¿Ğ¾Ñ‚Ğ¾ĞºĞµ
std::jthread task_thread(std::move(task), 10, 20);

std::cout << "Task result: " << task_future.get() << '\n';  // 30

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// std::shared_future - ĞœĞĞĞ–Ğ•Ğ¡Ğ¢Ğ’Ğ•ĞĞĞ«Ğ• get()
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/*
 * std::future       - get() Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ²Ñ‹Ğ·Ğ²Ğ°Ñ‚ÑŒ ĞĞ”Ğ˜Ğ Ñ€Ğ°Ğ·
 * std::shared_future - get() Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ²Ñ‹Ğ·Ğ²Ğ°Ñ‚ÑŒ ĞœĞĞĞ“Ğ Ñ€Ğ°Ğ·
 */

std::promise<int> shared_prom;
std::shared_future<int> shared_fut = shared_prom.get_future();

auto waiter = [](int id, std::shared_future<int> f) {
    std::cout << "Thread " << id << " waiting...\n";
    int value = f.get();  // âœ… ĞœĞ¾Ğ¶Ğ½Ğ¾ Ğ²Ñ‹Ğ·Ğ²Ğ°Ñ‚ÑŒ Ğ¼Ğ½Ğ¾Ğ³Ğ¾ĞºÑ€Ğ°Ñ‚Ğ½Ğ¾!
    std::cout << "Thread " << id << " got: " << value << '\n';
};

std::jthread t1(waiter, 1, shared_fut);
std::jthread t2(waiter, 2, shared_fut);
std::jthread t3(waiter, 3, shared_fut);

std::this_thread::sleep_for(100ms);
shared_prom.set_value(42);  // Ğ’ÑĞµ 3 Ğ¿Ğ¾Ñ‚Ğ¾ĞºĞ° Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ°Ñ‚ 42



// ============================================
// ğŸ“Œ THREAD POOL
// ============================================

class ThreadPool {
private:
    std::vector<std::jthread> workers_;
    std::queue<std::function<void()>> tasks_;
    std::mutex queue_mutex_;
    std::condition_variable cv_;
    bool stop_ = false;
    
public:
    explicit ThreadPool(size_t num_threads) {
        for (size_t i = 0; i < num_threads; ++i) {
            workers_.emplace_back([this] {
                while (true) {
                    std::function<void()> task;
                    
                    {
                        std::unique_lock<std::mutex> lock(queue_mutex_);
                        cv_.wait(lock, [this] { 
                            return stop_ || !tasks_.empty(); 
                        });
                        
                        if (stop_ && tasks_.empty()) {
                            return;
                        }
                        
                        task = std::move(tasks_.front());
                        tasks_.pop();
                    }
                    
                    task();
                }
            });
        }
    }
    
    template<typename F>
    auto enqueue(F&& f) -> std::future<decltype(f())> {
        using return_type = decltype(f());
        
        auto task = std::make_shared<std::packaged_task<return_type()>>(
            std::forward<F>(f)
        );
        
        std::future<return_type> result = task->get_future();
        
        {
            std::lock_guard<std::mutex> lock(queue_mutex_);
            if (stop_) {
                throw std::runtime_error("ThreadPool stopped");
            }
            tasks_.emplace([task]() { (*task)(); });
        }
        
        cv_.notify_one();
        return result;
    }
    
    ~ThreadPool() {
        {
            std::lock_guard<std::mutex> lock(queue_mutex_);
            stop_ = true;
        }
        cv_.notify_all();
    }
};

// Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ ThreadPool
ThreadPool pool(4);  // 4 Ñ€Ğ°Ğ±Ğ¾Ñ‡Ğ¸Ñ… Ğ¿Ğ¾Ñ‚Ğ¾ĞºĞ°

std::vector<std::future<int>> pool_results;

for (int i = 0; i < 8; ++i) {
    pool_results.emplace_back(
        pool.enqueue([i] {
            std::cout << \"Task \" << i << \"\\n\";\n            std::this_thread::sleep_for(100ms);\n            return i * i;\n        })\n    );\n}\n\nfor (auto& res : pool_results) {\n    std::cout << \"Result: \" << res.get() << '\\n';\n}\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// ğŸ“Œ std::osyncstream (C++20) - Ğ¡Ğ˜ĞĞ¥Ğ ĞĞĞ˜Ğ—Ğ˜Ğ ĞĞ’ĞĞĞĞ«Ğ™ Ğ’Ğ«Ğ’ĞĞ”\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n/*\n * std::osyncstream - Ğ°Ñ‚Ğ¾Ğ¼Ğ°Ñ€Ğ½Ñ‹Ğ¹ Ğ²Ñ‹Ğ²Ğ¾Ğ´ Ğ² std::cout Ğ±ĞµĞ· Ğ¿ĞµÑ€ĞµĞ¼ĞµÑˆĞ¸Ğ²Ğ°Ğ½Ğ¸Ñ\n * \n * âŒ Ğ‘Ğ•Ğ— osyncstream:\n * Thread 1Thread 2: output\n * : output  â† ĞŸĞµÑ€ĞµĞ¼ĞµÑˆĞ°Ğ½Ğ¾!\n * \n * âœ… Ğ¡ osyncstream:\n * Thread 1: output\n * Thread 2: output  â† ĞÑ‚Ğ¾Ğ¼Ğ°Ñ€Ğ½Ğ¾!\n */\n\nauto sync_worker = [](int id) {\n    std::osyncstream(std::cout) << \"Thread \" << id << \" output\\n\";\n    // Ğ’ĞµÑÑŒ Ğ²Ñ‹Ğ²Ğ¾Ğ´ Ğ°Ñ‚Ğ¾Ğ¼Ğ°Ñ€ĞµĞ½, Ğ½Ğµ Ğ¿ĞµÑ€ĞµĞ¼ĞµÑˆĞ°ĞµÑ‚ÑÑ Ñ Ğ´Ñ€ÑƒĞ³Ğ¸Ğ¼Ğ¸ Ğ¿Ğ¾Ñ‚Ğ¾ĞºĞ°Ğ¼Ğ¸\n};\n\nstd::jthread sync_t1(sync_worker, 1);\nstd::jthread sync_t2(sync_worker, 2);\n\n/*\n * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n * ğŸ¯ BEST PRACTICES - Ğ›Ğ£Ğ§Ğ¨Ğ˜Ğ• ĞŸĞ ĞĞšĞ¢Ğ˜ĞšĞ˜ ĞœĞĞĞ“ĞĞŸĞĞ¢ĞĞ§ĞĞĞ¡Ğ¢Ğ˜\n * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n * \n * 1ï¸âƒ£  ĞŸÑ€ĞµĞ´Ğ¿Ğ¾Ñ‡Ğ¸Ñ‚Ğ°Ğ¹Ñ‚Ğµ std::jthread Ğ²Ğ¼ĞµÑÑ‚Ğ¾ std::thread\n *     âœ“ ĞĞ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸Ğ¹ join Ğ² Ğ´ĞµÑÑ‚Ñ€ÑƒĞºÑ‚Ğ¾Ñ€Ğµ\n *     âœ“ Ğ’ÑÑ‚Ñ€Ğ¾ĞµĞ½Ğ½Ğ°Ñ Ğ¿Ğ¾Ğ´Ğ´ĞµÑ€Ğ¶ĞºĞ° stop_token\n *     â†’ ĞĞµÑ‚ Ñ€Ğ¸ÑĞºĞ° Ğ·Ğ°Ğ±Ñ‹Ñ‚ÑŒ join/detach\n * \n * 2ï¸âƒ£  Ğ’Ğ¡Ğ•Ğ“Ğ”Ğ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ RAII locks\n *     âœ“ std::lock_guard Ğ´Ğ»Ñ Ğ¿Ñ€Ğ¾ÑÑ‚Ñ‹Ñ… ÑĞ»ÑƒÑ‡Ğ°ĞµĞ²\n *     âœ“ std::unique_lock ĞºĞ¾Ğ³Ğ´Ğ° Ğ½ÑƒĞ¶Ğ½Ğ° Ğ³Ğ¸Ğ±ĞºĞ¾ÑÑ‚ÑŒ\n *     âœ“ std::scoped_lock Ğ´Ğ»Ñ ĞĞ•Ğ¡ĞšĞĞ›Ğ¬ĞšĞ˜Ğ¥ Ğ¼ÑŒÑÑ‚ĞµĞºÑĞ¾Ğ²\n *     âŒ ĞĞ˜ĞšĞĞ“Ğ”Ğ Ğ½Ğµ Ğ²Ñ‹Ğ·Ñ‹Ğ²Ğ°Ğ¹Ñ‚Ğµ mutex.lock()/unlock() Ğ²Ñ€ÑƒÑ‡Ğ½ÑƒÑ\n * \n * 3ï¸âƒ£  std::scoped_lock Ğ´Ğ»Ñ Ğ¼Ğ½Ğ¾Ğ¶ĞµÑÑ‚Ğ²ĞµĞ½Ğ½Ñ‹Ñ… Ğ¼ÑŒÑÑ‚ĞµĞºÑĞ¾Ğ²\n *     âœ“ ĞĞ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸ Ğ¿Ñ€ĞµĞ´Ğ¾Ñ‚Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµÑ‚ deadlock\n *     âœ“ ĞÑ‚Ğ¾Ğ¼Ğ°Ñ€Ğ½Ğ°Ñ Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²ĞºĞ° Ğ²ÑĞµÑ… Ğ¼ÑŒÑÑ‚ĞµĞºÑĞ¾Ğ²\n *     â†’ ĞŸĞ¾Ñ€ÑĞ´Ğ¾Ğº Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²ĞºĞ¸ Ğ½Ğµ Ğ²Ğ°Ğ¶ĞµĞ½\n * \n * 4ï¸âƒ£  ĞŸÑ€ĞµĞ´Ğ¿Ğ¾Ñ‡Ğ¸Ñ‚Ğ°Ğ¹Ñ‚Ğµ message passing Ğ²Ğ¼ĞµÑÑ‚Ğ¾ shared state\n *     âœ“ ThreadSafeQueue Ğ²Ğ¼ĞµÑÑ‚Ğ¾ shared Ğ¿ĞµÑ€ĞµĞ¼ĞµĞ½Ğ½Ñ‹Ñ…\n *     âœ“ ĞœĞµĞ½ÑŒÑˆĞµ ÑĞ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¸ â†’ Ğ¼ĞµĞ½ÑŒÑˆĞµ Ğ¾ÑˆĞ¸Ğ±Ğ¾Ğº\n *     â†’ \"Don't communicate by sharing memory, share memory by communicating\"\n * \n * 5ï¸âƒ£  Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ atomic Ğ´Ğ»Ñ ĞŸĞ ĞĞ¡Ğ¢Ğ«Ğ¥ Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸Ğ¹\n *     âœ“ Ğ¡Ñ‡ĞµÑ‚Ñ‡Ğ¸ĞºĞ¸, Ñ„Ğ»Ğ°Ğ³Ğ¸\n *     âœ“ Lock-free â†’ Ğ±Ñ‹ÑÑ‚Ñ€ĞµĞµ\n *     âŒ Ğ”Ğ»Ñ ÑĞ»Ğ¾Ğ¶Ğ½Ñ‹Ñ… Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸Ğ¹ â†’ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ mutex\n * \n * 6ï¸âƒ£  ĞœĞ¸Ğ½Ğ¸Ğ¼Ğ¸Ğ·Ğ¸Ñ€ÑƒĞ¹Ñ‚Ğµ ĞºÑ€Ğ¸Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸Ğµ ÑĞµĞºÑ†Ğ¸Ğ¸\n *     âœ“ Ğ”ĞµÑ€Ğ¶Ğ¸Ñ‚Ğµ lock Ğ¼Ğ¸Ğ½Ğ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ğ¾Ğµ Ğ²Ñ€ĞµĞ¼Ñ\n *     âœ“ Ğ’Ñ‹Ğ½Ğ¾ÑĞ¸Ñ‚Ğµ Ğ¼ĞµĞ´Ğ»ĞµĞ½Ğ½Ñ‹Ğµ Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸Ğ¸ Ğ—Ğ Ğ¿Ñ€ĞµĞ´ĞµĞ»Ñ‹ lock\n *     â†’ ĞœĞµĞ½ÑŒÑˆĞµ contention â†’ Ğ»ÑƒÑ‡ÑˆĞµ Ğ¿Ñ€Ğ¾Ğ¸Ğ·Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ¾ÑÑ‚ÑŒ\n * \n * 7ï¸âƒ£  ĞŸĞ ĞĞ¤Ğ˜Ğ›Ğ˜Ğ Ğ£Ğ™Ğ¢Ğ• Ğ¿ĞµÑ€ĞµĞ´ Ğ¾Ğ¿Ñ‚Ğ¸Ğ¼Ğ¸Ğ·Ğ°Ñ†Ğ¸ĞµĞ¹\n *     - Ğ˜Ğ·Ğ¼ĞµÑ€ÑĞ¹Ñ‚Ğµ Ñ€ĞµĞ°Ğ»ÑŒĞ½ÑƒÑ Ğ¿Ñ€Ğ¾Ğ¸Ğ·Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ¾ÑÑ‚ÑŒ\n *     - Bottleneck Ñ‡Ğ°ÑÑ‚Ğ¾ Ğ½Ğµ Ñ‚Ğ°Ğ¼ Ğ³Ğ´Ğµ Ğ²Ñ‹ Ğ´ÑƒĞ¼Ğ°ĞµÑ‚Ğµ\n *     â†’ \"Premature optimization is the root of all evil\"\n * \n * 8ï¸âƒ£  Ğ¢Ğ•Ğ¡Ğ¢Ğ˜Ğ Ğ£Ğ™Ğ¢Ğ• Ñ ThreadSanitizer (TSan)\n *     ĞšĞ¾Ğ¼Ğ¿Ğ¸Ğ»ÑÑ†Ğ¸Ñ: g++ -fsanitize=thread -g program.cpp\n *     âœ“ ĞĞ°Ñ…Ğ¾Ğ´Ğ¸Ñ‚ data races\n *     âœ“ ĞĞ°Ñ…Ğ¾Ğ´Ğ¸Ñ‚ deadlocks\n *     âœ“ ĞĞ°Ñ…Ğ¾Ğ´Ğ¸Ñ‚ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¿Ğ¾ÑĞ»Ğµ Ğ¾ÑĞ²Ğ¾Ğ±Ğ¾Ğ¶Ğ´ĞµĞ½Ğ¸Ñ\n *     â†’ Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ Ğ’Ğ¡Ğ•Ğ“Ğ”Ğ Ğ´Ğ»Ñ Ğ¼Ğ½Ğ¾Ğ³Ğ¾Ğ¿Ğ¾Ñ‚Ğ¾Ñ‡Ğ½Ğ¾Ğ³Ğ¾ ĞºĞ¾Ğ´Ğ°!\n * \n * 9ï¸âƒ£  Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ C++20 Ğ¿Ñ€Ğ¸Ğ¼Ğ¸Ñ‚Ğ¸Ğ²Ñ‹\n *     âœ“ std::jthread Ğ²Ğ¼ĞµÑÑ‚Ğ¾ thread\n *     âœ“ std::latch/barrier Ğ´Ğ»Ñ ÑĞ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¸ Ñ„Ğ°Ğ·\n *     âœ“ std::counting_semaphore Ğ´Ğ»Ñ rate limiting\n *     âœ“ atomic::wait/notify Ğ²Ğ¼ĞµÑÑ‚Ğ¾ condition_variable (Ğ³Ğ´Ğµ Ğ¿Ğ¾Ğ´Ñ…Ğ¾Ğ´Ğ¸Ñ‚)\n *     âœ“ std::osyncstream Ğ´Ğ»Ñ ÑĞ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ğ¸Ğ·Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ğ¾Ğ³Ğ¾ Ğ²Ñ‹Ğ²Ğ¾Ğ´Ğ°\n * \n * ğŸ”Ÿ Ğ˜Ğ·Ğ±ĞµĞ³Ğ°Ğ¹Ñ‚Ğµ recursive_mutex\n *     âš ï¸ ĞĞ±Ñ‹Ñ‡Ğ½Ğ¾ Ğ¿Ñ€Ğ¸Ğ·Ğ½Ğ°Ğº Ğ¿Ğ»Ğ¾Ñ…Ğ¾Ğ³Ğ¾ Ğ´Ğ¸Ğ·Ğ°Ğ¹Ğ½Ğ°\n *     â†’ Ğ›ÑƒÑ‡ÑˆĞµ Ğ¿ĞµÑ€ĞµĞ´ĞµĞ»Ğ°Ñ‚ÑŒ Ğ°Ñ€Ñ…Ğ¸Ñ‚ĞµĞºÑ‚ÑƒÑ€Ñƒ\n *     â†’ Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ ĞµÑĞ»Ğ¸ Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ¾ Ğ½ÑƒĞ¶ĞµĞ½\n * \n * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n * \n * Ğ”ĞĞŸĞĞ›ĞĞ˜Ğ¢Ğ•Ğ›Ğ¬ĞĞ«Ğ• Ğ Ğ•ĞšĞĞœĞ•ĞĞ”ĞĞ¦Ğ˜Ğ˜:\n * \n * â€¢ const correctness - Ğ¿Ğ¾Ğ¼Ğ¾Ğ³Ğ°ĞµÑ‚ ĞºĞ¾Ğ¼Ğ¿Ğ¸Ğ»ÑÑ‚Ğ¾Ñ€Ñƒ Ğ½Ğ°Ğ¹Ñ‚Ğ¸ race conditions\n * â€¢ Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ thread_local Ğ´Ğ»Ñ thread-specific Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…\n * â€¢ Ğ˜Ğ·Ğ±ĞµĞ³Ğ°Ğ¹Ñ‚Ğµ Ğ³Ğ»Ğ¾Ğ±Ğ°Ğ»ÑŒĞ½Ñ‹Ñ… Ğ¿ĞµÑ€ĞµĞ¼ĞµĞ½Ğ½Ñ‹Ñ…\n * â€¢ Ğ”Ğ¾ĞºÑƒĞ¼ĞµĞ½Ñ‚Ğ¸Ñ€ÑƒĞ¹Ñ‚Ğµ threading requirements (ĞºĞ°ĞºĞ¸Ğµ Ğ¼ĞµÑ‚Ğ¾Ğ´Ñ‹ thread-safe)\n * â€¢ Ğ Ğ°ÑÑĞ¼Ğ¾Ñ‚Ñ€Ğ¸Ñ‚Ğµ lock-free ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ñ‹ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… Ğ´Ğ»Ñ hot paths\n * â€¢ Ğ”Ğ»Ñ I/O bound Ğ·Ğ°Ğ´Ğ°Ñ‡ Ñ€Ğ°ÑÑĞ¼Ğ¾Ñ‚Ñ€Ğ¸Ñ‚Ğµ async I/O Ğ²Ğ¼ĞµÑÑ‚Ğ¾ Ğ¿Ğ¾Ñ‚Ğ¾ĞºĞ¾Ğ²\n * \n * Ğ˜ĞĞ¡Ğ¢Ğ Ğ£ĞœĞ•ĞĞ¢Ğ«:\n * - Valgrind/Helgrind - Ğ´Ğ»Ñ Ğ¿Ğ¾Ğ¸ÑĞºĞ° race conditions\n * - ThreadSanitizer (TSan) - Ğ»ÑƒÑ‡ÑˆĞ¸Ğ¹ Ğ¸Ğ½ÑÑ‚Ñ€ÑƒĞ¼ĞµĞ½Ñ‚ Ğ´Ğ»Ñ C++\n * - Intel Inspector - ĞºĞ¾Ğ¼Ğ¼ĞµÑ€Ñ‡ĞµÑĞºĞ¸Ğ¹ Ğ¸Ğ½ÑÑ‚Ñ€ÑƒĞ¼ĞµĞ½Ñ‚\n * \n * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n */

// ============================================
// ğŸ“Œ LOCK-FREE PROGRAMMING
// ============================================

// ĞŸÑ€Ğ¾ÑÑ‚Ğ¾Ğ¹ lock-free stack
template<typename T>
class LockFreeStack {
private:
    struct Node {
        T data;
        Node* next;
        Node(T d) : data(std::move(d)), next(nullptr) {}
    };
    
    std::atomic<Node*> head_{nullptr};
    
public:
    void push(T data) {
        Node* new_node = new Node(std::move(data));
        new_node->next = head_.load();
        
        // CAS loop - Ğ¿Ğ¾Ğ²Ñ‚Ğ¾Ñ€ÑĞµĞ¼ Ğ¿Ğ¾ĞºĞ° Ğ½Ğµ ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾
        while (!head_.compare_exchange_weak(new_node->next, new_node)) {
            // new_node->next Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½ Ñ‚ĞµĞºÑƒÑ‰Ğ¸Ğ¼ head_, Ğ¿Ğ¾Ğ²Ñ‚Ğ¾Ñ€ÑĞµĞ¼
        }
    }
    
    bool pop(T& result) {
        Node* old_head = head_.load();
        
        while (old_head && 
               !head_.compare_exchange_weak(old_head, old_head->next)) {
            // ĞŸĞ¾Ğ²Ñ‚Ğ¾Ñ€ÑĞµĞ¼ ĞµÑĞ»Ğ¸ Ğ´Ñ€ÑƒĞ³Ğ¾Ğ¹ Ğ¿Ğ¾Ñ‚Ğ¾Ğº Ğ¸Ğ·Ğ¼ĞµĞ½Ğ¸Ğ» head
        }
        
        if (!old_head) {
            return false;  // Ğ¡Ñ‚ĞµĞº Ğ¿ÑƒÑÑ‚
        }
        
        result = std::move(old_head->data);
        delete old_head;  // Ğ’ĞĞ˜ĞœĞĞĞ˜Ğ•: Ğ¿Ñ€Ğ¾Ğ±Ğ»ĞµĞ¼Ğ° ABA!
        return true;
    }
    
    ~LockFreeStack() {
        T dummy;
        while (pop(dummy)) {}
    }
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“Œ STOP TOKENS (C++20) - ĞšĞĞĞŸĞ•Ğ ĞĞ¢Ğ˜Ğ’ĞĞĞ¯ ĞĞ¡Ğ¢ĞĞĞĞ’ĞšĞ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// jthread Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸ Ğ¿Ñ€ĞµĞ´Ğ¾ÑÑ‚Ğ°Ğ²Ğ»ÑĞµÑ‚ stop_token
std::jthread stop_t([](std::stop_token stoken) {
    int count = 0;
    while (!stoken.stop_requested()) {
        std::cout << "Iteration " << count++ << '\n';
        std::this_thread::sleep_for(100ms);
        
        if (count >= 5) break;
    }
    
    if (stoken.stop_requested()) {
        std::cout << "Stop requested!\n";
    }
});

std::this_thread::sleep_for(250ms);
stop_t.request_stop();  // ĞšĞ¾Ğ¾Ğ¿ĞµÑ€Ğ°Ñ‚Ğ¸Ğ²Ğ½Ğ°Ñ Ğ¾ÑÑ‚Ğ°Ğ½Ğ¾Ğ²ĞºĞ°

// stop_source Ğ¸ stop_token Ğ½ĞµĞ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾
std::stop_source source;
std::stop_token token = source.get_token();

// Callback Ğ¿Ñ€Ğ¸ Ğ¾ÑÑ‚Ğ°Ğ½Ğ¾Ğ²ĞºĞµ
std::stop_callback callback(token, [] {
    std::cout << "Stop callback invoked!\n";
});

source.request_stop();  // Ğ’Ñ‹Ğ·Ğ¾Ğ²ĞµÑ‚ callback

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“Œ COMMON PATTERNS - Ğ¢Ğ˜ĞŸĞ˜Ğ§ĞĞ«Ğ• ĞŸĞĞ¢Ğ¢Ğ•Ğ ĞĞ«
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Thread-safe Singleton (C++11 Ğ³Ğ°Ñ€Ğ°Ğ½Ñ‚Ğ¸Ñ€ÑƒĞµÑ‚ thread-safety)
class Singleton {
private:
    Singleton() = default;
    
public:
    static Singleton& instance() {
        static Singleton inst;  // âœ… Thread-safe Ñ C++11
        return inst;
    }
    
    Singleton(const Singleton&) = delete;
    Singleton& operator=(const Singleton&) = delete;
};

// Monitor pattern - ÑĞ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ğ¸Ğ·Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğ¹ Ğ¾Ğ±ÑŠĞµĞºÑ‚
template<typename T>
class Monitor {
private:
    mutable std::mutex mutex_;
    T data_;
    
public:
    template<typename F>
    auto execute(F&& f) {
        std::lock_guard<std::mutex> lock(mutex_);
        return f(data_);
    }
    
    template<typename F>
    auto execute(F&& f) const {
        std::lock_guard<std::mutex> lock(mutex_);
        return f(data_);
    }
};

// Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Monitor
Monitor<std::vector<int>> mon;

mon.execute([](auto& vec) {
    vec.push_back(42);
});

auto size = mon.execute([](const auto& vec) {
    return vec.size();
});

// ĞŸĞ°Ñ‚Ñ‚ĞµÑ€Ğ½: Double-Checked Locking (Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ğ°Ñ Ğ²ĞµÑ€ÑĞ¸Ñ Ñ C++11)
class LazyInit {
private:
    static std::atomic<LazyInit*> instance_;
    static std::mutex mutex_;
    
    LazyInit() = default;
    
public:
    static LazyInit* get_instance() {
        LazyInit* tmp = instance_.load(std::memory_order_acquire);
        if (!tmp) {
            std::lock_guard<std::mutex> lock(mutex_);
            tmp = instance_.load(std::memory_order_relaxed);
            if (!tmp) {
                tmp = new LazyInit();
                instance_.store(tmp, std::memory_order_release);
            }
        }
        return tmp;
    }
};

std::atomic<LazyInit*> LazyInit::instance_{nullptr};
std::mutex LazyInit::mutex_;

// ============================================
// ğŸ“Œ PERFORMANCE & BEST PRACTICES
// ============================================

/*
 * FALSE SHARING - Ğ¿Ñ€Ğ¾Ğ±Ğ»ĞµĞ¼Ğ° Ğ¿Ñ€Ğ¾Ğ¸Ğ·Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ¾ÑÑ‚Ğ¸
 * 
 * ĞšĞ¾Ğ³Ğ´Ğ° Ğ´Ğ²Ğ° Ğ¿Ğ¾Ñ‚Ğ¾ĞºĞ° Ğ¾Ğ±Ñ€Ğ°Ñ‰Ğ°ÑÑ‚ÑÑ Ğº Ñ€Ğ°Ğ·Ğ½Ñ‹Ğ¼ Ğ¿ĞµÑ€ĞµĞ¼ĞµĞ½Ğ½Ñ‹Ğ¼,
 * Ğ½Ğ¾ Ğ¾Ğ½Ğ¸ Ğ½Ğ°Ñ…Ğ¾Ğ´ÑÑ‚ÑÑ Ğ² Ğ¾Ğ´Ğ½Ğ¾Ğ¹ cache line (Ğ¾Ğ±Ñ‹Ñ‡Ğ½Ğ¾ 64 Ğ±Ğ°Ğ¹Ñ‚Ğ°),
 * Ğ¿Ñ€Ğ¾Ğ¸ÑÑ…Ğ¾Ğ´Ğ¸Ñ‚ Ğ¿Ğ¾ÑÑ‚Ğ¾ÑĞ½Ğ½Ğ°Ñ Ğ¸Ğ½Ğ²Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ†Ğ¸Ñ ĞºĞµÑˆĞ° Ğ¼ĞµĞ¶Ğ´Ñƒ ÑĞ´Ñ€Ğ°Ğ¼Ğ¸.
 */

// âŒ ĞŸĞ›ĞĞ¥Ğ - False sharing
struct BadCounters {
    std::atomic<int> counter1;  // ĞœĞ¾Ğ³ÑƒÑ‚ Ğ±Ñ‹Ñ‚ÑŒ Ğ² Ğ¾Ğ´Ğ½Ğ¾Ğ¹ cache line
    std::atomic<int> counter2;
};

// âœ… Ğ¥ĞĞ ĞĞ¨Ğ - Ğ’Ñ‹Ñ€Ğ°Ğ²Ğ½Ğ¸Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¿Ğ¾ cache line
struct alignas(64) AlignedCounter {
    std::atomic<int> value;
};

struct GoodCounters {
    AlignedCounter counter1;  // Ğ“Ğ°Ñ€Ğ°Ğ½Ñ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ğ¾ Ğ² Ñ€Ğ°Ğ·Ğ½Ñ‹Ñ… cache lines
    AlignedCounter counter2;
};

/*
 * LOCK CONTENTION - Ğ±Ğ¾Ñ€ÑŒĞ±Ğ° Ğ·Ğ° Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²ĞºĞ¸
 * 
 * Ğ¡Ñ‚Ñ€Ğ°Ñ‚ĞµĞ³Ğ¸Ğ¸ ÑƒĞ¼ĞµĞ½ÑŒÑˆĞµĞ½Ğ¸Ñ:
 * 1. ĞœĞ¸Ğ½Ğ¸Ğ¼Ğ¸Ğ·Ğ¸Ñ€ÑƒĞ¹Ñ‚Ğµ ĞºÑ€Ğ¸Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸Ğµ ÑĞµĞºÑ†Ğ¸Ğ¸
 * 2. Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ lock-free ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ñ‹ Ğ³Ğ´Ğµ Ğ²Ğ¾Ğ·Ğ¼Ğ¾Ğ¶Ğ½Ğ¾
 * 3. Sharding - Ñ€Ğ°Ğ·Ğ´ĞµĞ»ĞµĞ½Ğ¸Ğµ Ğ½Ğ° Ğ½ĞµĞ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ñ‹Ğµ Ñ‡Ğ°ÑÑ‚Ğ¸
 * 4. Read-write locks Ğ´Ğ»Ñ read-heavy ÑÑ†ĞµĞ½Ğ°Ñ€Ğ¸ĞµĞ²
 */

// Sharding Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€
template<size_t N = 16>
class ShardedCounter {
private:
    struct alignas(64) Shard {
        std::atomic<int> value{0};
    };
    
    std::array<Shard, N> shards_;
    
    size_t get_shard() const {
        static thread_local size_t shard = std::hash<std::thread::id>{}(
            std::this_thread::get_id()
        ) % N;
        return shard;
    }
    
public:
    void increment() {
        ++shards_[get_shard()].value;
    }
    
    int total() const {
        int sum = 0;
        for (const auto& shard : shards_) {
            sum += shard.value.load();
        }
        return sum;
    }
};

/*
 * DEBUGGING TIPS:
 * 
 * 1. Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ ThreadSanitizer (TSan):
 *    g++ -fsanitize=thread -g program.cpp
 * 
 * 2. Valgrind Helgrind:
 *    valgrind --tool=helgrind ./program
 * 
 * 3. std::osyncstream (C++20) Ğ´Ğ»Ñ thread-safe Ğ²Ñ‹Ğ²Ğ¾Ğ´Ğ°:
 */

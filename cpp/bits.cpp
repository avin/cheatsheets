#include <bitset>
#include <iostream>
#include <cstdint>
#include <vector>
#include <print>  // C++23

// ---------------------------------------------------
// üìå –û—Å–Ω–æ–≤–Ω—ã–µ –±–∏—Ç–æ–≤—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏
// ---------------------------------------------------
void example_basic_bitwise() {
    int a = 5;  // 0101
    int b = 3;  // 0011

    int and_result = a & b;   // 0001 = 1
    int or_result = a | b;    // 0111 = 7
    int xor_result = a ^ b;   // 0110 = 6
    int not_result = ~a;      // –∏–Ω–≤–µ—Ä—Å–∏—è –≤—Å–µ—Ö –±–∏—Ç
    int left_shift = a << 1;  // 1010 = 10
    int right_shift = a >> 1; // 0010 = 2
}

// ---------------------------------------------------
// üìå –ü—Ä–æ–≤–µ—Ä–∫–∞, —É—Å—Ç–∞–Ω–æ–≤–∫–∞, —Å–Ω—è—Ç–∏–µ –±–∏—Ç–∞
// ---------------------------------------------------
bool getBit(int num, int pos) {
    return (num & (1 << pos)) != 0;
}

int setBit(int num, int pos) {
    return num | (1 << pos);
}

int clearBit(int num, int pos) {
    return num & ~(1 << pos);
}

int toggleBit(int num, int pos) {
    return num ^ (1 << pos);
}

// ---------------------------------------------------
// üìå –ü–æ–¥—Å—á—ë—Ç –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –µ–¥–∏–Ω–∏—á–Ω—ã—Ö –±–∏—Ç (popcount)
// ---------------------------------------------------
int countBits(int num) {
    int count = 0;
    while (num) {
        count += num & 1;
        num >>= 1;
    }
    return count;
}

int countBitsBuiltin(int num) {
    return __builtin_popcount(num);
}

int countBitsBuiltin64(long long num) {
    return __builtin_popcountll(num);
}

// ---------------------------------------------------
// üìå –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ —Å—Ç–µ–ø–µ–Ω—å –¥–≤–æ–π–∫–∏
// ---------------------------------------------------
bool isPowerOfTwo(int num) {
    return num > 0 && (num & (num - 1)) == 0;
}

// ---------------------------------------------------
// üìå –ü–æ–ª—É—á–µ–Ω–∏–µ –º–ª–∞–¥—à–µ–≥–æ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω–æ–≥–æ –±–∏—Ç–∞
// ---------------------------------------------------
int lowestSetBit(int num) {
    return num & -num;
}

// ---------------------------------------------------
// üìå –°–Ω—è—Ç–∏–µ –º–ª–∞–¥—à–µ–≥–æ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω–æ–≥–æ –±–∏—Ç–∞
// ---------------------------------------------------
int clearLowestBit(int num) {
    return num & (num - 1);
}

// ---------------------------------------------------
// üìå –ë–∏—Ç–æ–≤—ã–µ –º–∞—Å–∫–∏ –∏ —Ñ–ª–∞–≥–∏
// ---------------------------------------------------
void example_flags() {
    const uint32_t FLAG_READ = 1 << 0;    // 0001
    const uint32_t FLAG_WRITE = 1 << 1;   // 0010
    const uint32_t FLAG_EXEC = 1 << 2;    // 0100
    const uint32_t FLAG_ADMIN = 1 << 3;   // 1000

    uint32_t permissions = 0;

    // –£—Å—Ç–∞–Ω–æ–≤–∫–∞ —Ñ–ª–∞–≥–æ–≤
    permissions |= FLAG_READ;
    permissions |= FLAG_WRITE;

    // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ñ–ª–∞–≥–∞
    bool canRead = (permissions & FLAG_READ) != 0;

    // –°–Ω—è—Ç–∏–µ —Ñ–ª–∞–≥–∞
    permissions &= ~FLAG_WRITE;

    // –ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ —Ñ–ª–∞–≥–∞
    permissions ^= FLAG_EXEC;
}

// ---------------------------------------------------
// üìå –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –≤—Å–µ—Ö –ø–æ–¥–º–Ω–æ–∂–µ—Å—Ç–≤ (–±–∏—Ç–æ–≤—ã–µ –º–∞—Å–∫–∏)
// ---------------------------------------------------
void generateSubsets(int n) {
    int totalSubsets = 1 << n;
    for (int mask = 0; mask < totalSubsets; ++mask) {
        std::print("–ü–æ–¥–º–Ω–æ–∂–µ—Å—Ç–≤–æ: ");
        for (int i = 0; i < n; ++i) {
            if (mask & (1 << i)) {
                std::print("{} ", i);
            }
        }
        std::println("");
    }
}

// ---------------------------------------------------
// üìå –ò—Ç–µ—Ä–∞—Ü–∏—è –ø–æ –≤—Å–µ–º —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω—ã–º –±–∏—Ç–∞–º
// ---------------------------------------------------
void iterateSetBits(int num) {
    while (num) {
        int lowestBit = num & -num;
        int bitPosition = __builtin_ctz(lowestBit); // count trailing zeros
        std::println("–ë–∏—Ç –Ω–∞ –ø–æ–∑–∏—Ü–∏–∏: {}", bitPosition);
        num &= num - 1; // —Å–Ω–∏–º–∞–µ–º –º–ª–∞–¥—à–∏–π –±–∏—Ç
    }
}

// ---------------------------------------------------
// üìå –†–∞–±–æ—Ç–∞ —Å std::bitset
// ---------------------------------------------------
void example_bitset() {
    std::bitset<8> bits("10101010");

    bits.set(0);        // —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –±–∏—Ç 0
    bits.reset(1);      // —Å–±—Ä–æ—Å–∏—Ç—å –±–∏—Ç 1
    bits.flip(2);       // –∏–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å –±–∏—Ç 2

    bool bit3 = bits[3];
    size_t count = bits.count();  // –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –µ–¥–∏–Ω–∏—Ü
    bool all = bits.all();        // –≤—Å–µ –±–∏—Ç—ã = 1?
    bool any = bits.any();        // —Ö–æ—Ç—è –±—ã –æ–¥–∏–Ω = 1?
    bool none = bits.none();      // –≤—Å–µ –±–∏—Ç—ã = 0?

    std::string str = bits.to_string();
    unsigned long num = bits.to_ulong();
}

// ---------------------------------------------------
// üìå Swap –¥–≤—É—Ö —á–∏—Å–µ–ª –±–µ–∑ –≤—Ä–µ–º–µ–Ω–Ω–æ–π –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π (XOR trick)
// ---------------------------------------------------
void swapXOR(int& a, int& b) {
    if (&a != &b) {  // –∑–∞—â–∏—Ç–∞ –æ—Ç swap(x, x)
        a ^= b;
        b ^= a;
        a ^= b;
    }
}

// ---------------------------------------------------
// üìå –ü–æ–∏—Å–∫ –µ–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω–æ–≥–æ —á–∏—Å–ª–∞ (–≤—Å–µ –æ—Å—Ç–∞–ª—å–Ω—ã–µ –≤—Å—Ç—Ä–µ—á–∞—é—Ç—Å—è –¥–≤–∞–∂–¥—ã)
// ---------------------------------------------------
int findSingle(const std::vector<int>& nums) {
    int result = 0;
    for (int num : nums) {
        result ^= num;
    }
    return result;
}

// ---------------------------------------------------
// üìå –ü–æ–ª—É—á–µ–Ω–∏–µ –∑–Ω–∞–∫–æ–≤–æ–≥–æ –±–∏—Ç–∞
// ---------------------------------------------------
bool isNegative(int num) {
    return (num >> 31) & 1;
}

// ---------------------------------------------------
// üìå –ê–±—Å–æ–ª—é—Ç–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –±–µ–∑ –≤–µ—Ç–≤–ª–µ–Ω–∏–π
// ---------------------------------------------------
int absNoBranch(int num) {
    int mask = num >> 31;
    return (num + mask) ^ mask;
}

// ---------------------------------------------------
// üìå –ú–∏–Ω–∏–º—É–º/–º–∞–∫—Å–∏–º—É–º –±–µ–∑ –≤–µ—Ç–≤–ª–µ–Ω–∏–π
// ---------------------------------------------------
int minNoBranch(int a, int b) {
    return b ^ ((a ^ b) & -(a < b));
}

int maxNoBranch(int a, int b) {
    return a ^ ((a ^ b) & -(a < b));
}

// ---------------------------------------------------
// üìå –†–∞–∑–≤–æ—Ä–æ—Ç –±–∏—Ç –≤ —á–∏—Å–ª–µ
// ---------------------------------------------------
uint32_t reverseBits(uint32_t num) {
    uint32_t result = 0;
    for (int i = 0; i < 32; ++i) {
        result = (result << 1) | (num & 1);
        num >>= 1;
    }
    return result;
}

// ---------------------------------------------------
// üìå –ü–æ–¥—Å—á—ë—Ç —Å—Ç–∞—Ä—à–∏—Ö –Ω—É–ª–µ–π (leading zeros)
// ---------------------------------------------------
int countLeadingZeros(unsigned int num) {
    return __builtin_clz(num);
}

// ---------------------------------------------------
// üìå –ü–æ–¥—Å—á—ë—Ç –º–ª–∞–¥—à–∏—Ö –Ω—É–ª–µ–π (trailing zeros)
// ---------------------------------------------------
int countTrailingZeros(unsigned int num) {
    return __builtin_ctz(num);
}

// ---------------------------------------------------
// üìå –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ª–µ–¥—É—é—â–µ–π —Å—Ç–µ–ø–µ–Ω–∏ –¥–≤–æ–π–∫–∏
// ---------------------------------------------------
uint32_t nextPowerOfTwo(uint32_t num) {
    if (num == 0) return 1;
    num--;
    num |= num >> 1;
    num |= num >> 2;
    num |= num >> 4;
    num |= num >> 8;
    num |= num >> 16;
    return num + 1;
}
